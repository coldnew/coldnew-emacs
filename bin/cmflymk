#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Author: Chen Bin <chenbin DOT sh AT GMAIL>
# URL: https://github.com/redguartoo/pycmake-flymake
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#   
#   See http://www.gnu.org/copyleft/gpl.html for licence details.

mk_name="Makefile" #or Makefile.flymake?
prog="cmflymk"

import fnmatch,os,re,getopt,sys

def guess_root_src_dir(build_dir):
    global mk_name
    p1=re.compile("^CMAKE_SOURCE_DIR\s*=(.+)$")
    mkfile=os.path.join(build_dir,mk_name)
    for l in open(mkfile,'r').readlines():
        m=p1.match(l)
        if m:
            src_dir=m.group(1)
            return src_dir.strip()
    return ""

def create_makefile(build_dir,root_src_dir,cm,executable):
    global mk_name
    global prog
    cm_dir=os.path.dirname(cm)
    flag_make=build_dir+cm_dir.replace(root_src_dir,"",1)+"/CMakeFiles/"+executable+".dir/flags.make"
    mk_path=os.path.join(cm_dir,mk_name)
    txt="# Generated by "+prog+". Run '"+prog+" -c' to remove it\n" \
        +"include "+flag_make+"\n" \
        +".PHONY: check-syntax\ncheck-syntax:\n\t${CXX} -o /dev/null ${CXX_FLAGS} ${CXX_DEFINES} -S ${CHK_SOURCES}"

    f=open(mk_path,"w")
    f.write(txt)
    f.close()

def clean_makefiles():
    global mk_name
    matches = []
    for root, dirnames, filenames in os.walk("."):
        for filename in fnmatch.filter(filenames, 'CMakeLists.txt'):
            matches.append(os.path.join(root, mk_name))
    print "Deleted "+mk_name+":"
    for f in matches:
        f=os.path.abspath(f)
        if os.path.isfile(f):
            print f
            os.remove(f)

def usage():
    global prog
    global mk_name
    message="""SYNOPSIS
       {program} [options] [build_dir]

USAGE
       {program} ~/my_project/build
           create {mk} for flymake

       {program} -c 
           clean {mk} {program} produced recursively
    """
    print message.format(program=prog,mk=mk_name)

if __name__=="__main__":
    try:
        opts,args=getopt.getopt(sys.argv[1:],"hc",["help","clean"])
    except getopt.GetoptError, err:
        usage()
        sys.exit(2)
    
    for o, a in opts:
        if o in ("-c", "--clean"):
            clean_makefiles()
            sys.exit()
        elif o in ("-h","--help"):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option"

    if len(args)==0:
        usage()
        sys.exit()

    build_dir=os.path.abspath(args[0])
    root_src_dir=guess_root_src_dir(build_dir)

    p=re.compile('\s*add_executable\(\s*(\w+)', re.IGNORECASE)
    
    matches = []
    for root, dirnames, filenames in os.walk(root_src_dir):
        for filename in fnmatch.filter(filenames, 'CMakeLists.txt'):
            matches.append(os.path.join(root, filename))
    
    #each cmake file
    for cm in matches:
        for l in open(cm,'r').readlines():
            m=p.match(l)
            if m:
                executable=m.group(1)
                create_makefile(build_dir,root_src_dir,cm,executable)
                break

# Local Variables:
# tab-width:4
# indent-tabs-mode:nil
# End:
# vim: set expandtab tabstop=4 shiftwidth=4:

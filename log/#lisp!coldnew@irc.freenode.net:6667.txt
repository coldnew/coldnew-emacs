
[Wed Aug 22 2012]
*** Topic for #lisp: Common Lisp, the #1=(programmable . #1#) programming
    language <http://paste.lisp.org/new>. New: Drakma 1.2.7, Hunchentoot 1.2.4,
    SBCL 1.0.58, ABCL 1.0.1, CMUCL 20c  [15:58]
*** #lisp: topic set by H4ns!hans@netzhansa.com, 04:51:11 2012/08/17
*** Users on #lisp: coldnew naeg Kryztof ow homie`` cmatei varjag trigen_ mishoo
    Ottre agumonkey punee ferada eni em harish LaughingMan dan64 ur5us
    ivan-kanis answer_42 gko pspace Cymew mrSpec hkBst sbryant sshirokov
    AntiSpamMeta edgar-rft jeekl moore33 angavrilov ArmyOfBruce quazimodo Jasko
    changedNicks ramkrsna otwieracz kushal zmyrgel lcc kennyd benny kpreid kcj
    fold permagreen Yuuhi`` zodiac1111 Kvaks ji9 springz yrk neoesque cfy
    PuercoPop420 dim kuzary smithzv gurrag prip
*** Users on #lisp: Nisstyre bjorkintosh quasisane rvchangue nanoc Modius
    robot-beethoven Vutral [SLB] proq xan_ sellout42 axion Vivitron` tritchey
    loke _fogus_ bobbysmith007 naiv teiresias dan_dan__ sykopomp kliph qsun
    brendyn JPeterson Xof ghast billstclair abeaumont z0d theos superflit
    keltvek flip214 rdd kirin` scharan Sgeo Natch kleppari fmeyer CampinSam
    loke_erc arrdem bzzbzz DT` arrsim ered hpd s0ber pnkbst setmeaway Oddity
    brandonz Praise lucca joast Guest36974 jnbek|wc
*** Users on #lisp: H4ns hswe hlavaty felideon gekko_ acelent dRbiG eudicot
    DaDaDOSPrompt aerique Khisanth mcsontos rtj ntd piko quackv4 joshe pierre__
    mathrick Euthy arunganesan Quadrescence cmm- jmcphers BlastHardcheese jsnell
    _3b basho drewc df_ magnific1ab ianmcorvidae Xach |3b| r126f trbotime
    Codynyx eMBee daimrod p_l BeLucid Spaceghostc2c phadthai rvirding
    denysonique NimeshNeema SeanTAllen Gurragchaa Posterdati johs arbscht maxm
    setheus basso_ stokachu naryl ivan\ mikaelj
*** Users on #lisp: ZombieChicken nicdev srcerer Zemyla cmbntr foom limetree
    pchrist Tuxedo ikariW fe[nl]ix macrobat brown` araujo DGASAU Yamazaki-kun
    antifuchs sawjig ameoba schme jaxtr Tordek antoszka Axioplase ``Erik
    hiredman tvaalen_ renard_ dfox PECCU turbolen1 sporous tali713 ace4016
    kanru_ impulse newcup cataska clop weinholt ozzloy sigjuice_ elliottc1ble
    nuba Subfusc fasta_ chr` cipher` gilez theBlackDragon REPLeffect SHODAN
    Patzy nightfly hugod xristos mal__ TristamWrk
*** Users on #lisp: sytse redline6561_ ineiros andrewsw kanru cola_zero_
    __class__ Ralith stepnem nullman madnificent ChoHag tkd rtoym surrounder
    wolgo howeyc cYmen drdo gemelen CrazyEddy djinni`_ boyscared adeht ramus
    freiksenet slyrus frodef les jfe dmiles_afk ccl-logbot mtd literal clog pok_
    The_third_man gf3 tomaw spacefrogg^ nitro_idiot oGMo felipe rotty ft vsync
    Bucciarati jasom guther scode __main__ egn galdor cods xaxisx Obfuscate xian
    gabot j_king copec zbigniew
*** Users on #lisp: acieroid robonyankitty gensym vhost- _root_ _schulte_ _tca
    yroeht Guest63158 DrForr fmu jayne Mandus froydnj slava @Zhivago finnrobi
    housel anddam Odin- Zol rfgpfeiffer dnm_ rabite_ ecraven guaqua NNshag
    minion ofan froggey Yahovah_ pjb herbieB pkhuong koisoke mon_key derrida
    specbot tessier Fade dsp_ yan_ Buglouse kyl jasox wyan yeltzooo7 Borbus
*** #lisp modes: +Ccn  [15:59]
*** #lisp was created on Monday 2003/08/04 05:30:32 AM
*** changedNicks (pule@unaffiliated/changednicks) is now known as sweet|kid
									  [16:35]
* madnificent expected the link of ToArmsToArms to be A) about Fieldy B)
  relevant.  needs wakeup coffee  [16:50]
<mtd> loke_erc: nice talk - didn't know there was much CL in SIN  [16:54]
<loke_erc> mtd: Me neither. I'm doing what I can though :-)  [16:58]
<robot-beethoven> (hunchentoot:create-static-file-dispatcher-and-handler
		 "/data.json" *data-path* "application/json") is serving as a
		 binary file... how do i get hunchentoot to serve json as text?
									  [17:48]
<stassats> text/json?
<madnificent> application/json should be right though, the accepting application
	      is a bit off i think  [17:50]
<madnificent> text/plain should work too, in case you want to be the naughty kid
	      which really just wants to read it as text  [17:51]
<robot-beethoven> madnificent: do you mean that json is supposed to be served as
		 binary?  [17:52]
<[6502]> Hello... what are the practical advantages of using uninterned symbols?
<pjb> So that you cannot read them back.
<pjb> When you read back a normal symbol, you get it.  When you read back a
      uninterned symbol, you get a new one, different from the original.  [17:53]
<[6502]> a practical case in which this is good?
<pjb> For private variables or functions.
<[6502]> but you cannot call them, no?
<pjb> If you have a reference to them, you can.  [17:54]
<[6502]> oh... instead of (gensym)
<pjb> (defmacro d (e) (let ((s (gensym))) `(let ((,s ,e)) (+ ,s ,s))))
<[6502]> sorry...
<[6502]>  i know and truly love gensym
<pjb> if you didn't use a uninterned symbol for the variable name here, you
      could have this variable in the expression e, possibly with a modification
      form such as incf, and obtain wrong results.  [17:55]
<[6502]> I was talking about those other uninterned symbols
<madnificent> robot-beethoven: application/json is the right mime-type for a
	      json response.  the application which tries to accept the json
	      document seems to do something wrong if it doesn't want the json
	      document with that mimetype.  you may want to do something
	      different for debugging purposes though (however, if it is for
	      browser-stuff, it should just be fine).
<pjb> [6502]: I'm only talking about those uninterned symbols.
<pjb> I'm not talking about Santa Claus.
<moore33> Heh, what's the longest people here have gone without writing  Lisp
	  code?  [17:56]
<pjb> (- 1996 1964) 32 years for me.  [17:57]
<moore33> I don't think that counts.
<[6502]> pjb: i seem to remember a special reader syntax for uninterned symbols
<pjb> #:x
<moore33> Unless you are older than I believe :)
<stassats> what kind of question is that?
<[6502]> pjb: ok... what's that useful for?  [17:58]
<stassats> [6502]: to be able to read uninterned symbols
<pjb> (let ((#1=#:x (* 2 2))) (+ #1# #1#))
<[6502]> ahhhhhhh
* [6502] loves that let  [17:59]
* [6502] always sort of hated the idea the let symbols were interned
<robot-beethoven> madnificent: oh, it was the silly mistake: i typed
		 "appliaction/json" wrong
<[6502]> also in most macro (not all of them , of course) the use of (gensym)
	 could be replaced by '#:xxx  [18:00]
<pjb> But not always.  [18:01]
<[6502]> i said most
<pjb> It is often important to have different symbols, eg. when the macro can be
      embedded into itself.
<[6502]> pjb: if it's used for a let there should be no problem anyway  [18:02]
<stassats> pjb: different names
<pjb> Depends on the macro.
<[6502]> i said most
<stassats> no, macros should never use uninterned unchanging symbols  [18:03]
<[6502]> btw implementing that reader feature of #1= ... is annoying
<[6502]> not the reader... but who produces the output
<[6502]> it has to scan the whole thing twice  [18:04]
<stassats> unless you feel like reading macroexpansion of two macros with
	   different variables but similar looking names
<[6502]> just to see if there are any back references
<[6502]> stassats: no one likes that :-D
<stassats> [6502]: you don't have to scan it twice  [18:05]
<[6502]> stassats: no? how can you do?
<stassats> upon encountering #1#, you save the cons it's in, and when you see
	   #1=, you modify the saved cons  [18:06]
* [6502] used a simplified version for his toy: e.g.  (let ((x (list 1 2)))
  (push x x) x) ==> "(1 2 #0)"  [18:07]
<[6502]> stassats: reading is the easy part. you need to scan twice for writing
<stassats> clhs 2.4.8.16  [18:08]
<specbot> Sharpsign Sharpsign:
	  http://www.lispworks.com/reference/HyperSpec/Body/02_dhp.htm
<stassats> "forward references are not permitted", problem solved
<moore33> Except there's  the whole *print-circle* thing...  [18:09]
<stassats> [6502]: how is writing related to it?
<[6502]> stassats: you're still talking about READING. the annoying part is
	 producing the output... you have to see first if there will be later
	 any backreference (to emit "#n=")
<stassats> tough luck, *print-circle* is off by default  [18:10]
<loke_erc> [6502]: you could produce #n= for everything, even if you don't
	   backreference them. Problem solved.
<loke_erc> :-)
<moore33> It still needs to be supported, even if it is off by default.  [18:11]
<[6502]> loke_erc: indeed in my toy i just produce output numbering lists. #n is
	 a back reference to the n-th opened list
<stassats> moore33: it's like the least difficult part of the CL standard, i
	   don't see how it could be annoying or anything
<[6502]> loke_erc: to simplify reading as it's in CL you need to scan twice when
	 doing the output. Not horribily difficult but annoying...  [18:12]
<moore33> stassats: I don't claim that is annoying, but useful print-circle
	  support implies passing  over the data twice.  [18:13]
<stassats> so, passing over the data twice is a no-no?
<moore33> Possibly I am confusing *print-circle* and *print-shared*.
<madnificent> robot-beethoven: ah, that makes sense :)
<moore33> stassats:Not as far as I'm concerned.  [18:14]
<stassats> moore33: there's no *print-shared*
<stassats> moore33: it's more of a question to [6502]
<[6502]> ouch
<stassats> but he's known for such petty concerns
<moore33> stassats: Sorry, I'm confounding *print-circle*, *print-length* and
	  *print-level*. See my earlier question :)  [18:16]
<[6502]> ahhh... good, (let ((x (list 1 2))) (list x x)) emits (#1=(1 2)
	 #1#)... i've had a doubt that only was used for "circles"
<stassats> well, why don't you dispel any doubts with a healthy dose of CLHS?
<[6502]> why is it named *print-circle* then ?  [18:17]
<moore33> indeed
<stassats> because it allows you to print circular structures  [18:18]
* moore33 wonders how many dead email addresses are in the CLHS credits.
<pjb> stassats: #1=#(a b #1# c d) ; what cons?  [18:19]
<stassats> pjb: what cons?
<pjb> Where do you see a cons cell in  #1=#(a b #1# c d) ???
* [6502] saw #n= used in source code just to avoid retyping...  [18:20]
<stassats> pjb: i don't understand that question, but (a b #1# c d) looks
	   ostensibly like a cons cell  [18:21]
<pjb> ## in source code is dangerous because while sharing tails is ok, circular
      source _code_ doesn't have to be handled by the interpreters or compilers.
* [6502] wonders how happy would be a source leve debugger about that
<[6502]> unless you set *compile-circle* :-D  [18:22]
<stassats> pjb: and if you were asking about handling forward-references,
	   forward references are not allowed  [18:24]
<pjb> No, I wasn't.  [18:25]
<pjb> <12:07:15><stassats> upon encountering #1#, you save the cons it's in, and
      when you see #1=, you modify the saved cons
<pjb> what cons cell?
<stassats> that was about forward-references  [18:26]
<stassats> forward-references are not allowed, so you can move along  [18:27]
<stassats> but if they were, and to handle vector, you could save the vector
	   itself with an index  [18:29]
<pjb> #= and ## should also work thru personalized reader macros.  [18:30]
<pjb> See the recursive-p parameter of READ READ-DELIMITED-LIST etc.  [18:31]
<moore33> hmm, mapcan or loop  [18:36]
* moore33 goes with loop.  [18:38]
<stassats> mapcan, if you don't have to add LAMBDA, loop otherwise  [18:53]
*** Guest36974 (~quassel@83.151.30.10) is now known as Jabberwockey  [19:46]
<jaxtr> ahh it's a wonderful day  [20:27]
<trebor_dki> hello. in sbcl - what is the intended function to get the
	     process-id of the current running lisp-process?
	     sb-unix::unix-getpid or sb-posix::getpid or something else_
									  [20:28]
<trebor_dki> ?\
<Xach> trebor_dki: sb-unix is not for users.  [20:29]
<Xach> trebor_dki: if sb-posix:getpid is external, that is the one
<trebor_dki> Xach: thank you.  [20:31]
<Xach> looks like it is external  [20:33]
*** p_l (~pl@web1.rootnode.net) is now known as p_l|laggy  [21:04]
<ghast> hi. is it possible to get a new sbcl repl connected to the existing
	slime repl? (so i don't have to open another sbcl instance). i'm
	curious.  [21:17]
<H4ns> ghast: you can start a swank server (swank:create-server) and then use
       slime-connect  [21:24]
<ghast> ooh
<ghast> i see
<ghast> so it's possible  [21:25]
<ghast> great
<ghast> thank you
<seabass> Morning everyone.  I've got a function where I might have some
	  information pre-computed, or I might need to compute it on the fly.
	  What's the proper way to deal with that?  Optional arguments?
									  [21:36]
<stassats> seabass: what do you mean by "pre-computed"?  [21:37]
<stassats> is it a result of some other function?
<seabass> It's the mean of a set of numbers.  Depending on where I call this
	  function from, I might have already computed it because I needed it to
	  do something else.  [21:38]
<seabass> I'm just trying to save myself the cost of computing the mean in the
	  even that I have it laying about.
<H4ns> seabass: if you sometimes have the data at the call site and you are not
       bothered by the extra arguments, use optional (or, better yet, keyword)
       arguments.  [21:39]
<stassats> seabass: (set-of-numbers &key (mean (compute-mean set-of-numbers)))
									  [21:40]
<seabass> oh, that's clever.
<seabass> Can you do computations that are dependent on one another that way?
<stassats> yes  [21:41]
<stassats> the dependency is only one way
<seabass> That's great.  Thanks a lot folks.  [21:42]
<sykopomp> felideon: hi  [21:45]
<felideon> sykopomp: good morning!
*** ehu` (~ehuels@109.34.77.219) is now known as ehu  [22:06]
<stassats> suddenly, the russian invasion on Planet Lisp  [22:08]
* j_king welcomes our russian friends.  [22:19]
* madnificent would welcome them even more if he had a clue what they were
  talking about  [22:21]

[Wed Aug 22 2012]
*** Topic for #lisp: Common Lisp, the #1=(programmable . #1#) programming
    language <http://paste.lisp.org/new>. New: Drakma 1.2.7, Hunchentoot 1.2.4,
    SBCL 1.0.58, ABCL 1.0.1, CMUCL 20c  [23:56]
*** #lisp: topic set by H4ns!hans@netzhansa.com, 04:51:11 2012/08/17
*** Users on #lisp: coldnew Bike quazimodo [6502] brudgers gravicappa harish
    jcazevedo ocmsRzr clintm cfy iLogical Xach lcc rmarianski sambio wbooze
    qptain_Nemo Guest31228 pavelpenev iocor teggi philth udzinari tensorpudding
    phax Jasko stassats peterhil` sykopomp basho nanoc lain__ FreeArtMan VieiraN
    fantazo theos naeg flavioribeiro ofan trebor_dki ipmonger rvchangue gko
    mattrepl m7w KingsKnighted pskosinski jtza8 ignas attila_lendvai dfox
    mvilleneuve peterhil Alice3 bitonic
*** Users on #lisp: gekko_ antonv Houl moore33 xian schme mikaelj BeLucid
    dan_dan__ Kryztof ow cmatei trigen_ mishoo Ottre punee em dan64 ivan-kanis
    answer_42 sbryant sshirokov AntiSpamMeta jeekl angavrilov ArmyOfBruce
    sweet|kid otwieracz kennyd benny kpreid fold permagreen zodiac1111 Kvaks ji9
    PuercoPop420 dim kuzary smithzv gurrag prip Nisstyre bjorkintosh quasisane
    Modius robot-beethoven Vutral [SLB] proq xan_ sellout42 axion Vivitron`
    tritchey loke `fogus|eats bobbysmith007
*** Users on #lisp: naiv teiresias kliph qsun brendyn JPeterson Xof ghast
    billstclair abeaumont z0d superflit keltvek flip214 rdd kirin` scharan Sgeo
    Natch kleppari fmeyer CampinSam loke_erc arrdem bzzbzz DT` arrsim ered hpd
    s0ber pnkbst setmeaway Oddity brandonz Praise lucca joast Jabberwockey
    jnbek|wc H4ns hswe felideon acelent dRbiG eudicot DaDaDOSPrompt aerique
    Khisanth mcsontos rtj ntd piko quackv4 joshe nowhere_man mathrick Euthy
    arunganesan Quadrescence cmm- jmcphers
*** Users on #lisp: BlastHardcheese jsnell _3b drewc df_ magnific1ab
    ianmcorvidae |3b| r126f trbotime Codynyx eMBee daimrod p_l|laggy
    Spaceghostc2c phadthai rvirding denysonique NimeshNeema SeanTAllen
    Gurragchaa Posterdati johs arbscht maxm setheus basso_ stokachu naryl ivan\
    ZombieChicken nicdev srcerer Zemyla cmbntr foom limetree pchrist Tuxedo
    ikariW fe[nl]ix macrobat brown` araujo DGASAU Yamazaki-kun antifuchs sawjig
    ameoba jaxtr Tordek antoszka Axioplase ``Erik hiredman
*** Users on #lisp: tvaalen_ renard_ PECCU turbolen1 sporous tali713 ace4016
    kanru_ impulse newcup cataska clop weinholt ozzloy sigjuice_ elliottc1ble
    nuba Subfusc fasta_ chr` cipher` gilez theBlackDragon REPLeffect SHODAN
    Patzy nightfly hugod xristos mal__ TristamWrk sytse redline6561_ ineiros
    andrewsw cola_zero_ __class__ Ralith stepnem nullman madnificent tkd
    surrounder wolgo howeyc cYmen drdo gemelen finnrobi @Zhivago slava froydnj
    Mandus jayne fmu DrForr Guest63158 yroeht
*** Users on #lisp: _tca _schulte_ _root_ vhost- gensym robonyankitty acieroid
    zbigniew copec j_king gabot Obfuscate xaxisx cods galdor egn __main__ scode
    guther oGMo nitro_idiot spacefrogg^ tomaw gf3 The_third_man pok_ clog
    literal mtd ccl-logbot felipe rotty ft vsync Bucciarati jasom housel anddam
    Odin- Zol rfgpfeiffer dnm_ rabite_ ecraven guaqua NNshag minion froggey
    Yahovah_ pjb herbieB pkhuong koisoke mon_key derrida specbot tessier Fade
    dsp_ yan_ Buglouse kyl jasox wyan
*** Users on #lisp: yeltzooo7 Borbus dmiles_afk jfe les frodef slyrus freiksenet
    ramus adeht boyscared djinni`_
<stassats> sellout42: let* would be let***
* pavelpenev dusts off his Russian-Bulgarian dictionary and goes to planet
  lisp...doesn't need your stinkin' translator algorithms.
<clintm> Is there any way to limit the amount of entries returned by instance
	 queries in Elephant?  I can't find anything in the docs, but I thought
	 I'd ask before I refactored.
*** #lisp modes: +Ccn
*** #lisp was created on Monday 2003/08/04 05:30:32 AM
<sellout42> pavelpenev: Hah â€“ yeah, I tried really hard to read that post this
	    morning ;)
<stassats> and i just didn't want to read it
<Fade> machine xlation of Vsevolod Dyomkin's blog:
       http://coruscant.deepsky.com:8080/rYlZb  [23:57]
<stassats> "how to combine functional languages with the mainstream" doesn't
	   sound that interesting
<Fade> notable only for the introduction of the term "Hipsterskie" to my
       lexicon.  [23:58]
<[6502]> sellout42: it expands in a let with all variables undefined, wrapping a
	 labels with all functions and then the initialization is done using
	 setf in sequence. The important point is that during initialization and
	 inside local functions all bindings are visible. Neither let nor let*
	 do this...
<p_l|laggy> Fade: hhahaha  [23:59]
<p_l|laggy> "hipsteric" :)
<p_l|laggy> or "hipster"
<stassats> is hipsteric like hipster, but more hysteric?

[Thu Aug 23 2012]
<p_l|laggy> stassats: more of my error. "hip" I guess?  [00:00]
* p_l|laggy is unaccustomed of dealing with hipsters
* clintm refactors to postmodern...
* Xach got his hipster Quicklisp Q-star stickers yesterday
<clintm> stickers?  ooo...  [00:01]
<pavelpenev> Yes, slavianization of English slang is always hilarious.
<stassats> well, it's quite hip to label everything as "hip" nowadays
<Xach> http://www.zazzle.com/quicklisp_q_star_sticker-217868504417177584
<[6502]> clintm: there's also a list of authorized tatoo shops  [00:02]
<clintm> [6502]: heh... tattoos.  one sec, let me find a picture of mine.
<stassats> Xach: poor brand recognitino
<stassats> recognition  [00:03]
<clintm> [6502]: birthday present from my wife: http://snurl.com/24qlni1  [00:04]
<[6502]> clintm: and (y) stands for ? :-)  [00:05]
<Xach> in that case try
       http://www.zazzle.com/lambda_star_sticker-217479066423747247 - based on
       xach.com/misc/lambda.html
<Xach> sticker does not spin
<clintm> [6502]: never looked at it that way.  Supposed to be a lambda.  [00:06]
<clintm> way too many "Oh dude, Half Life!!! zomg!" comments.  Didn't think of
	 that either when I got it.  [00:07]
<clintm> Not that I don't like Half Life...
<DT`> clintm, woah, are you gordon freeman?  [00:08]
<clintm> heh
<DT`> I mean, it's the symbol from HL2!
<[6502]> clintm: hahahaha... half life, i didn't thought about it either
<stassats> what will you do when you grow out of lambda calculus?
<[6502]> stassats: laser
<DT`> stassats, how can you grow out of lambda calculus?  [00:09]
<sellout42> stassats: It can probably be modified into a Ï€.
<Fade> Ï„ uber alles  [00:12]
<stassats> getting a tatoo is like hard-coding constants into your code, not
	   easy to modify, now, getting an e-ink display implant is much better
									  [00:13]
<Xach> H4ns: phew  [00:15]
<H4ns> Xach: :D
<Xach> H4ns: i kept forgetting to ask about it. was the bug at least
       interesting?  [00:17]
<H4ns> Xach: not at all.  the gateway did not handle "tweet too long" gracefully
									  [00:18]
<clintm> "This beautiful quicklisp sticker design submitted by a Seller called
	 wigflip was tagged: quicklisp, quicklisp, and quicklisp."
<clintm> no, really.  quicklisp.
<H4ns> Xach: and for some reason, twitter now counts tweet lengths before it
       shorts urls again.
<clintm> heh
<H4ns> Xach: also interestingly, twitter told the gateway that your post was a
       duplicate, but still distributed it to everyone  [00:20]
* H4ns can't but think that twitter is breaking apart.
<chenbing>  I remerber in emacs slime can type "m-v-b" into
	   "multiple-value-bind", is it ture and how?  [00:22]
<H4ns> chenbing: M-TAB
<H4ns> oops.  chenbing: that was C-c TAB  [00:23]
<|3b|> M-tab works here
<stassats> C-M-i as an alternative  [00:24]
<stassats> or just TAB at the REPL
<|3b|> (possibly typed as esc tab or M-C-i to avoid window managers
       misinterpreting it)
<H4ns> oh, nice.  M-TAB works here, too :)
<Fade> annoyingly, my wm is trapping M-C-i  [00:25]
<chenbing> bingo C-M-I fit for me best
<Fade> .oO(Oh look, I minimized emacs again!)
<madnificent> C-c C-i works too  [00:26]
* chenbing couldn't help laugh
<chenbing> one way to one thing style (python?) is my favorite
<stassats> C-i = TAB
<madnificent> M-TAB seems to be more relaxing, thanks H4ns
<chenbing> my keyboard seems refuse m-tab  [00:27]
<stassats> so, it's M-TAB and C-c TAB
<stassats> chenbing: that's highly unlikely  [00:28]
<Fade> yeah. I just had M-C-i in the muscle memory in my hands.
<pavelpenev> M-TAB is used by many window managers, I have  (local-set-key [tab]
	     'slime-complete-symbol) in my lisp-mode-hook function in .emacs
									  [00:32]
<ghast> pavelpenev: what key do you use to indent?  [00:34]
<stassats> pavelpenev: tab is used for indentation, you might want to use
	   slime-indent-and-complete-symbol instead  [00:35]
<pavelpenev>  (local-set-key (kbd "M-q") 'slime-reindent-defun)
<ghast> stassats: nice idea
<pavelpenev> stassats: I might try that
<stassats> M-q is already bound to paredit-reindent-defun, if you use paredit
									  [00:37]
<pavelpenev> I think I wrote that before i started using paredit. Might be time
	     for some .emacs clean up :)  [00:39]
* pavelpenev must attend some meatspace business now.  [00:41]
*** superflit_ (~superflit@67-41-144-184.hlrn.qwest.net) is now known as
    superflit  [00:45]
<herbieB> Is there a handy way to disable input buffering in sbcl on linux?
									  [01:06]
<stassats> herbieB: on which streams?
<herbieB> *standard-input*  [01:07]
<herbieB> Basically iw ant read-char to be immediately responsive
<stassats> open a new one
<stassats> sb-sys:make-fd-stream
<stassats> wait, you want it to be immediately responsive as the user types?
									  [01:08]
<herbieB> Basically
<stassats> well, buffering ain't gonna help here, you need to convince your
	   terminal to do that  [01:09]
<herbieB> Ah, ok
<pjb> herbieB: you can use cl-ncurses  [01:10]
<herbieB> That's probably overkill  [01:12]
<madnificent> herbieB: 'what are you trying to solve exactly?' as stassats
	      normally puts it so well when it gets to this point  [01:14]
<herbieB> He got that, I wanted sbcl to be responsive immediately to user input
	  for a little toy thing I'm doing.  stdbuf didn't do the trick, so I
	  was wondering if there was some workaround from inside sbcl
									  [01:15]
<stassats> prepare to learn about termios  [01:17]
*** `fogus|eats (~fogus@burke-matrex.d-a-s.com) is now known as `fogus  [01:18]
<herbieB> Yeah, and making ffi calls for the purpose of this program is nearly
	  as overkill as using cl-ncurses  [01:19]
<stassats> well, it's the only way
<herbieB> Indeed
*** dyCrazyEd (~deepsome@wrongplanet/CrazyEddy) is now known as CrazyEddy
									  [01:26]
*** tali713` (~tali713@c-75-72-193-140.hsd1.mn.comcast.net) is now known as
    tali713  [01:39]
<pjb> herbieB: cl-ncurses is portable!  [01:44]
<stassats> does ncurses work on windows?  [01:46]
<killerboy> lol
<pjb> There are curses libraries for MS-Windows.
<Xach> yeah, and x servers too, so X is portable
<pjb> So it could, if it doesn't.
<stassats> if you want portability, just replace all the sb-posix with cffi (or
	   petition fe[nl]ix), and add a case for windows  [01:47]
*** p_l|laggy (~pl@web1.rootnode.net) is now known as p_l  [01:52]
*** superflit_ (~superflit@216-160-161-137.hlrn.qwest.net) is now known as
    superflit  [02:27]
*** ofan_ (~ofan@199.180.254.36) is now known as ofan  [02:31]
*** PuercoPop712 (~PuercoPop@190.41.173.174) is now known as help
<trebor_d`> hm. i am overlooking something very obvious... i am starting several
	    instances of a binary generated via save-lisp-and-die and need them
	    to have a different random-state. (make-random-state t) obviously is
	    not the solution. using sth like (get-internal-real-time) seems not
	    to be the right way either ... is there a portable way to get each
	    instance a separate random-state?  [03:04]
*** killerbo1 (~mateusz@217.17.38.43) is now known as killerboy
<pjb> trebor_d`: when you save the image, you can give a function to be run when
      the image is reloaded.  Initialize the random state there.  [03:05]
<stassats> trebor_d`: why isn't make-random-state the solution?  [03:06]
<trebor_d`> stassats: all instances will have the same random-state then (tested
	    by printing (random 1000000) at start after (make-random-state t)
									  [03:07]
<|3b|> did you change *random-state* to the new random-state?
<stassats> do you do (setf *random-state* (make-random-state t)) at each start
	   up?
<trebor_d`> can i please delete the last 5 minutes of this in all your memories
	    please ....  [03:08]
*** help (~PuercoPop@190.41.173.174) is now known as PuercoPop  [03:16]
* trebor_d` hails lisp for its good nature of generating working applications
  even for ignorants like me. unbelievable ...  [03:21]
*** trebor_d` (~user@kvpn.lbf.fraunhofer.de) is now known as trebor_dki  [03:23]
*** sweet|kid (pule@unaffiliated/changednicks) is now known as upasna  [03:31]
*** ianmcorvidae|alt (~ianmcorvi@ip72-200-124-178.tc.ph.cox.net) is now known as
    ianmcorvidae  [03:39]
*** pirateking_ (~piratekin@c-67-169-182-169.hsd1.ca.comcast.net) is now known
    as pirateking-_-  [04:06]
<black_joe> I have some weird output coming from a pythagorean theorem
	    function. Google and various books couldn't clarify the problem.
									  [04:29]
<black_joe> Function definition: (defun ptgSide (hypot side1) (+ 0.0 (sqrt (-
	    (square hypot) (square side1)))))
<black_joe> Output: #C(0.0 3)
<Bike> A complex number.
<black_joe> The #C is unfamiliar. And the 0.0 shouldn't be there either.
<Bike> #c(0.0 3) is 3i  [04:30]
<pkhuong> black_joe: are you sure you haven't swapped the arguments?
<black_joe> Yes. I am sure of that.
<black_joe> So is there any way to prevent it from evaluating to a complex
	    number? Or to convert the complex number into a decimal number?
									  [04:31]
<Bike> That you got a complex number means that the argument to sqrt is
       negative.
<black_joe> When I googled the problem I just got things relating to C#. So
	    thanks for telling me the name of it.
<pkhuong> black_joe: you might want to brush up on high school math then. What's
	  the square root of -9?
<Bike> (ptgside 5 4) => 3.0  [04:32]
<black_joe> Oh. I did screw the arguments up when I called it.
<black_joe> Not in the function.
<black_joe> I am not even in High School yet. But... Nothing, right?
<black_joe> Since if you multiply two negatives it yields a positive?
<Bike> heh, heh.  [04:33]
<punee> how endearing
<Bike> With complex numbers it's 3i.
<Bike> i being (sqrt -1).
<Bike> If you're only dealing with real numbers there is no answer, yeah, but
       Lisp includes complexes.  [04:34]
<black_joe> So then Complex numbers are specific to Lisp?
<Bike> No, like pkhuong said, it's high school mathematics.  [04:35]
<black_joe> I'll see when I come to it. It looks useful. Up until now I thought
	    negative numbers were un-square rootable.
<pjb> Complexes are just like rationals, but for reals.
<pjb> :-)
<didi> pjb: I'm constantly crashing CLISP while using CFFI. I actually have no
       idea of I'm doing, but just to ask: Do you know if CLISP have some
       inherent problem with CFFI?  [04:36]
<pjb> didi: not at all. clisp has one of the best FFI around.
<didi> Nice.
<pjb> The problem is the C code you're calling.
<pjb> That's why I think it's better if you just rewrite the library in Lisp.
<didi> pjb: That would be awesome, but I'm afraid I'm not capable of such. But
       that's fine.  [04:37]
<pjb> When you call a Lisp function, if you make a mistake, you enter the
      debugger and get a nice error message.  When you can a C function, if you
      make a mistake, you crash the process.
<pjb> So you use a C library only if you know it: there's no way to learn it by
      introspection.  [04:38]
<didi> I know it quite well, actually. It's just the CFFI interface, types,
       functions that are actually macros, callbacks and all that fun stuff.
									  [04:39]
*** kushal (~kdas@114.143.160.192) is now known as Guest77882  [04:48]
*** dan64 (dan64@2600:3c03::f03c:91ff:fedf:7dc0) is now known as Guest14436
*** ofan (~ofan@199.180.254.36) is now known as Guest84466
*** [SLB] (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now
    known as Guest3961
*** denysonique (u484@gateway/web/irccloud.com/x-isbluugtipjwanxs) is now known
    as Guest68848  [04:49]
*** BlastHardcheese (chris@pool-108-38-205-87.lsanca.dsl-w.verizon.net) is now
    known as Guest78395
<pjb> It might be a good idea to wrap the C functions in Lisp functions that
      check the parameters, call the C function with the right parameters, and
      signal lisp errors when the C library indicates an "error".
<pjb> The "thick" interface vs. the "thin" interface.
*** Guest78395 (chris@pdpc/supporter/active/blasthardcheese) is now known as
    BlastHardcheese  [04:50]
*** Guest3961 (~slabua@unaffiliated/slabua) is now known as [SLB]  [04:53]
*** superflit_ (~superflit@209-180-240-133.hlrn.qwest.net) is now known as
    superflit  [05:12]
<arrdem>  /join #clojure  [05:17]
*** dan_dan__ (~dan@gateway/tor-sasl/dan) is now known as dan  [05:23]
<felideon> blasphemy  [05:38]
<Fade> maybe just youthful indiscretion.  [05:40]
<didi> Let's embrace diversity and Lisp.
<anvandare> group (parenthetic) hug!  [05:43]
<didi> \o/  [05:44]
<madnificent> (hug)  [05:48]
<Cosman246> Does anyone here still go to comp.lang.lisp?  [05:50]
<stassats> the trolls and spammers do
<didi> Cosman246: That's a sad place.
<Cosman246> didi: indeed  [05:51]
<Cosman246> A lot of them appear to be mad  [05:55]
*** Obfuscate` (~keii@unaffiliated/obfuscate) is now known as Obfuscate  [06:07]
<pavelpenev> Cosman246: There is actually a list of mad people on
	     comp.lang.lisp: http://www.tfeb.org/lisp/mad-people.html
									  [06:15]
<stassats> Cosman246: now you know not to go there  [06:16]
<_travis_> pavelpenev, thank you for that link. this is a very entertaining
	   read!  [06:43]
* anvandare bangs his head against the wall  [06:51]
<phadthai> pavelpenev: :))  [06:52]
<stassats> you, laughing at other people's misfortunes, it's not their fault
	   they're mad!
<pavelpenev> and in the case of cthun, he was probably programmed that way.
									  [06:54]
<_travis_> i cant help but wonder how different newsgroups for things like cll
	   were 10 years ago...  [06:55]
<_travis_> and how much more i would have learned reading them back then
* pavelpenev gave reading cll a chance about the same time he appeared, revoked
  that chance pretty quickly
<anvandare> you could check google groups :P
<_travis_> yeah i know… but it's not the same as reading real-time and
	   participating in some :)
<anvandare> you could still answer to a post from '83!
<phadthai> actually, "madness" is very ambigious anyway, so the post can't be
	   taken seriously either  [06:59]
<phadthai> _travis_: "the list that makes people mad"  [07:01]
<phadthai> s/list/newsgroup/  [07:02]
<Cosman246> what link?  [07:03]
<Cosman246> what link about cll?  [07:04]
<pavelpenev> Cosman246:  http://www.tfeb.org/lisp/mad-people.html  [07:05]
<Cosman246> ah yes
<anvandare> hatters gonna hat
<Cosman246> Xah Lee especially, because he's very intelligent, but just mad
<felideon> s/mad/misunderstood  [07:14]
<Cosman246> also has a big ego  [07:15]
<anon119> i didn't the email =p  [07:45]
<anon119> =[
<stassats> who is Dimitri Fontaine?  [08:33]
<stassats> why do people write wrong things on their blogs and don't even have a
	   comments functionality?  [08:34]
<Bike> the "fast and stupid" article?  [08:36]
<stassats> yes
<ace4016> because to the unsuspecting reader, there are no comments to take away
	  from the author's percieved intelligence  [08:37]
<Bike> it says he wouldn't mind a CL guy telling him what's up, but has no
       contact info...
<stassats> the result of that function on (expt 10 10) is 66 bits
<stassats> ccl screws up and overflows the fixnum
<stassats> and, it's a silly benchmark anyhow  [08:38]
<Bike> there's an email on his github.  [08:39]
<stassats> with proper declarations ccl will take ages to compute it  [08:40]
<stassats> and he's not even using unsigned long ints in c  [08:41]
<stassats> so, the whole post is crap
<Cosman246> fast and stupid article?
<stassats> yes, they article is stupid indeed  [08:42]
<Cosman246> no, no--what's the article?
<Bike> just google "dimitri
<Bike> *dimitri fontaine
<stassats> Cosman246: planet.lisp.org
<stassats> the only proper code is for python, which shows how slow it is
									  [08:43]
<Cosman246> A lot of the python community acts cultish
<Cosman246> But I digress
<stassats> dim: see above  [08:50]
<stassats> i can only offer a faster solution: (defun sum-fast (max) (/ (* max
	   (1+ max)) 2))  [08:52]
<stassats> too bad the compilers aren't smart enough to deduce that  [08:58]
<luck_dog> hello everyone , can we make a 3d engine use lisp?  [11:21]
<luck_dog> it maybe fun  [11:22]
<luck_dog> nobody :-[  [11:24]
<Cosman246> luck_dog: I think there  [11:29]
<Cosman246> *there's been some work on that
<Cosman246> See CL-OPENGL and LISPBUILDER-SDL  [11:30]
<luck_dog> as if not easy  [11:36]
<DataLinkDroid> luck_dog: see also #lispgames
<pnathan> luck_dog: yes you can make a 3D engine use lisp.  [11:49]
<pnathan> two ways to do it
<pnathan> 1, write it all in lisp
<pnathan> 2. write lisp in your game, ala ECL
<pnathan> I betcha the ECL way is the most effective  [11:50]
<pjb> luck_dog: go as on #lispgames
<pjb> ask
<Bike> luck_dog: there is a 3d lisp game engine, Blackthorn.  [11:51]
<pkhuong> or call out to a C engine from lisp.
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [12:46]
<drcode> hi all  [13:23]
<drcode> what is lisp?
<drcode> dose it cross platform lang?  [13:24]
<bjorkintosh> yes it does.
<bjorkintosh> if you push it slightly, it crosses platform lang.
<bjorkintosh> here, give it a push.
<pjb> drcode: http://en.wikipedia.org/wiki/Common_Lisp http://cliki.net
<drcode> it mean I can write one code and compile it in
	 windows,linux,mac,ios,android?  [13:27]
<pjb> Yes
<H4ns> drcode: ios and android not so much  [13:28]
<pjb> There are serveral implementaions, one is enough.
<drcode> H4ns: what do u mean?
<drcode> can I use cffi with lisp on cross platform include android and ios?
<pjb> Nothing, he's just rambling.
<H4ns> drcode: i mean that there is no common lisp on ios or android that would
       be suitable to application delivery
<pjb> There are: ecl, ccl, etc.  [13:29]
<drcode> I see
<drcode> lisp work like python  , it will need run time?
<H4ns> drcode: of course, if you want to deliver a fibonacci number calculator,
       you'll be able to do so on android and ios as well, with a little pushing
<drcode> ok
<pjb> drcode: even C needs a run time! What the fuck are you asking here?
									  [13:30]
<drcode> I think to use ext, share ib
<drcode> lib
<drcode> dose lisp support cffi?
<pjb> What else supports CFFI?
<drcode> neko
<pjb> drcode: stop trolling, it's not funny.
<didi> Cat?
<drcode> ok  [13:31]
* H4ns loled
<drcode> sorry
<didi> Could someone take a look at this <http://paste.kde.org/538436/>? It's a
       function that's supposed to be calling a C function, using CFFI. Am I
       doing it right?  [14:12]
<pkhuong> didi: are you sure freeing all that is a good idea?  [14:13]
<didi> pkhuong: Hum...
<didi> That's a good question.
<didi> Yeah... I think you're right.  [14:14]
<didi> Oh well, take two.
<didi> pkhuong: Just for a moment, let's say "yes" (although it's not). I'm
       calling the function correctly and then cleaning it up?  [14:17]
<pkhuong> didi: no clue. I don't use cffi.
<didi> oic
<pkhuong> the string foreign alloc seems to do a lot of magic. I'd double check
	  that the strings are correctly null-terminated and that they're not
	  allocated all at once.  [14:18]
<Bike> i think you can use defcfun to simplify things?  [14:19]
<didi> Bike: Maybe, but I don't know how I would define the types to make the
       conversion.  [14:20]
<Bike> I think it does that automatically.  [14:21]
<Bike> The manual has Â«(defcfun "strlen" :int (n :string)) (strlen "123") => 3Â»
									  [14:22]
<mskou72> Is there a prefered (django-like) web framework for Lisp?
<didi> Bike: But what about an array of string pointers?  [14:23]
<jack_rabbit> mskou72, have a look at hunchentoot. It's just a webserver I
	      think, but it has a bunch of links on its site for CL web
	      development.  [14:25]
<didi> pkhuong: I'm basically coping this part of the manual
       <http://paste.kde.org/538448/>
<mskou72> I have played with hunchentoot but was looking for something with
	  templatesystem and orm.  [14:26]
<Bike> oh, well if that's how the tutorial does it...
<didi> mskou72: Lisp is the ultimate template system. ;^)  [14:27]
<H4ns> mskou72: for templates, you could look at html-template.
<H4ns> mskou72: for orm, there is cl-sql, elephant and cl-perec
<H4ns> mskou72: there is nothing in lisp that resembles rails in integrating all
       of it
<mskou72> ok, we should build/assemble that :-)  [14:29]
<H4ns> mskou72: "hah"  [14:30]
<mskou72> yes, good joke, i know :-)
<mskou72> we just got to figure out a cool name for it first!  [14:32]
<H4ns> who is the "we" you keep on talking about?
<Bike> there is such a thing as "lisp on lines"  [14:33]
<H4ns> right.  and claw.  and bknr.
<mskou72> there is no I in we :-/
<H4ns> none of which has much traction.  face it:  lisp will stay fragmented.
       it is best to improve the fragments rather than dreaming of the
       all-encompassing megaframework.  [14:34]
<jack_rabbit> H4ns, not the most rousing of speeches.  [14:38]
<H4ns> jack_rabbit: i'm not a marketing person.
<jack_rabbit> :)  [14:39]
<Ralith> quick, someone hire a marketing person
<jack_rabbit> I feel like lispers are the native americans of software
	      development.  [14:40]
<H4ns> heh
<bjorkintosh> this should be interesting.
<bjorkintosh> how exactly, jack_wabbit?
<jack_rabbit> Well. We have lisp, which many lispers will tell you is the best
	      language on the planet, and yet libraries and support seem to be,
	      as H4ns said, fragmented and under-developed.  [14:41]
<H4ns> jack_rabbit: i did not say under-developed
<bjorkintosh> oh that's because hardly anyone actually uses it for anything.
<jack_rabbit> I apologize if I've offended any Native Americans.  [14:42]
<bjorkintosh> s'ok, when i go to the cherokee casino, i will tell them
	      jack_rabbit said sorry for what he said.
<jack_rabbit> bjorkintosh, or does hardly anyone actually use it for anything
	      because it has poor library support?
<bjorkintosh> it is likelier that i will go to osage. so osage casino.
<jack_rabbit> H4ns: sorry to put words in your mouth.  [14:43]
<H4ns> what is this "poor library support" that you're talking about?
<bjorkintosh> the libraries are fine.
<jack_rabbit> H4ns: maybe I'm insane then. It's quite possible.
<H4ns> all i said is that an attempt to build a framework which "integrates"
       "everything" is futile.
<H4ns> jack_rabbit: no, i'm interested in knowing what you mean by "poor"
       exactly?  [14:44]
<jack_rabbit> I've probably overstepped my knowledge here, so I'll be quiet now.
<jack_rabbit> H4ns, From what I can see, it's hard to find a currently
	      maintained library or framework for the things that one might want
	      a library or framework for, or at least much harder than it is to
	      find one in C or comparable languages.  [14:45]
<jack_rabbit> H4ns, but I'm still a relative newbie, so I probably should have
	      just not begun speaking.
<H4ns> jack_rabbit: well, i need to agree to some degree.  i can enumerate gui,
       oauth, websocket as areas where lisp libraries are under-developed.
									  [14:46]
<H4ns> jack_rabbit: and what i conclude from that is that someone needs to
       develop these libraries better rather than trying to rewrite rails before
       knowing lisp properly.
<jack_rabbit> H4ns, :)  [14:47]
<jack_rabbit> H4ns, I think my issue is that i can find like 5 libraries for
	      socket-interfaces, but they are all old and no longer actively
	      developed, or they have a very small developer base. It is, as you
	      said, fragmented.  [14:48]
<bjorkintosh> eh. it is really not so bad is it?
<bjorkintosh> things still work.
<jack_rabbit> bjorkintosh, not so bad, but for one of the oldest languages, it's
	      pretty bad.
<H4ns> jack_rabbit: if you'd ask here, you'd get two answers.  use usocket.  and
       use iolib (as the world only matters with posix)
<pkhuong> usocket, iolib, and what else?
<pkhuong> jack_rabbit: I'd expect older languages to have more old and inactive
	  libraries.  [14:49]
<bjorkintosh> jack_rabbit, how are the socket-interface libraries in cobol and
	      fortran these days?  [14:50]
<H4ns> bjorkintosh: i'd expect them to be very cool
<jack_rabbit> pkhuong, maybe, but I'd also expect it to have many old maintained
	      libraries.
<bjorkintosh> H4ns, to the touch.
<H4ns> jack_rabbit: and i agree again:  it is hard to see the good things with
       all that dead crap lying about
<jack_rabbit> bjorkintosh, I guess the difference is that there are those that
	      think that lisp is still very useful, wheras cobol and fortran
	      maybe are less useful when compared to other, newer languages.
									  [14:51]
<H4ns> "we need to preserve all these good projects, because in the future,
       someone might pick them up and revive them" my ass
<jack_rabbit> bjorkintosh, useful syntax, that is.
<bjorkintosh> jack_rabbit, they have their niches.
<pkhuong> jack_rabbit: CL has had more time to accmulate chaff. #lisp-ers have
	  often sieved through most of it and can recommend good libraries.
<didi> Fortran is still very useful for things like Octave.
<bjorkintosh> and those niches have proved difficult to breach.
<H4ns> i estimate that of the 435 "projects" on common-lisp.net, 90% are 100%
       dead  [14:52]
<bjorkintosh> lisp's niche is barely alive.
<bjorkintosh> and yes, i mean AI.
<H4ns> bjorkintosh: haha
<H4ns> bjorkintosh: who told you that lisp's niche is ai?  [14:53]
<pkhuong> bjorkintosh: AI disagrees.
<bjorkintosh> H4ns, no one. just the numerous textbooks which utilized the
	      language.
<bjorkintosh> i know it is a general purpose language.
<jack_rabbit> I find much more support for lisp on the internet than I do for
	      cobol or fortran.
<bjorkintosh> jack_rabbit, that is because those who support cobol and fortran
	      charge an arm and a leg.
<H4ns> bjorkintosh: lisp's niche is the lisp hackers.  and there are enough of
       them to sustain themselves.  [14:54]
<bjorkintosh> no reason for them to make said support free.
<pkhuong> jack_rabbit: Fortran has a ton of very awesome and up-to-date books.
<jack_rabbit> both documentation support and cheerleader support.
<Bike> fortran is still a thing in plenty of places, have you seen the automatic
       differentiators?
<H4ns> it is very easy to get confused about programming language aliveness if
       you judge from reading hackernews or stackoverflow.
<bjorkintosh> that is correct, H4ns.  [14:55]
<jack_rabbit> H4ns, fair enough.
<bjorkintosh> jack_rabbit, what would you like to be able to do with lisp, which
	      seems so difficult now?  [14:56]
<jack_rabbit> My problem seems to be that from the box I'm in, Lisp seems much
	      more alive than many other languages, and the
	      support/documentation for the libraries seems scattered and
	      unorganized.
<bjorkintosh> hmm.  [14:57]
<jack_rabbit> I did find the gigamonkeys book, which is amazing.
* jack_rabbit is trying to get out of his box.
<bjorkintosh> there is a reason emacs keeps getting bigger and bigger. what you
	      want, is probably written in elisp already.
<jack_rabbit> emacs is almost its own OS.  [14:58]
<bjorkintosh> for a good reason.
<jack_rabbit> or or Desktop environment, more accurately.
<didi> Emacs is awesome!
<jack_rabbit> I use Emacs for everything.
<jack_rabbit> except IRC, ironically.
<bjorkintosh> you can use it for that too.
<jack_rabbit> bjorkintosh, yep. I just haven't configured it yet.  [14:59]
<jack_rabbit> bjorkintosh, Also on my small laptop screen, it's a pain to keep
	      swapping the buffers.
<jack_rabbit> while I code.
<bjorkintosh> eh? get a second monitor.
<bjorkintosh> correction. procure a second monitor!  [15:00]
<jack_rabbit> I shall procure one!
<jack_rabbit> One which is a widescreen, and rotates 90 degrees for long code
	      page viewing pleasure!  [15:01]
<bjorkintosh> there you go.
<bjorkintosh> that way, you can spend all your time writing extensions in elisp,
	      and never get around to building a great framework for commonlisp.
									  [15:02]
<bjorkintosh> and you will finally understand why such things happen.
<jack_rabbit> bjorkintosh, There are just so many small worlds to explore.
<didi> Well, I know that with only `program-name' I can safely free the stuff
       I've allocated. <http://paste.kde.org/538454/> With this version, CLISP
       stopped crashing, although the code seems messy.  [15:23]
<jack_rabbit> goodnight.  [15:28]
<didi> I think I'm starting to get CFFI. Slow and steady, slow and steady.
									  [16:01]
*** [SLB]` (~slabua@unaffiliated/slabua) is now known as [SLB]  [16:24]
<pjb> didi: you can use swig to generate cffi bindings from C headers.  google
      for swig cffi.  [17:03]
<didi> pjb: I will, thanks.  [17:04]
<ferada> hi all, so for testing procedural code, that is, with no objects to
	 override, is it viable to rebind functions (eg. using setf fdefinition)
	 during a test (assuming no inlining and so on)? and are therey testing
	 libs which do this already?  [17:06]
<pjb> pkhuong: by "inactive libraries", you mean stable, refined, useful and
      well debugged libraries, right?
<pjb> ferada: that, or read those symbol in a different package.  [17:07]
<pjb> Instead of (defpackage :your-package (:use :cl :somelib)) do (defpackage
      :your-package (:use :cl :somelib-stub))
<pjb> and define those stub functions in somelib-stub  instead of somelib.
<pjb> ferada: also, while you could break an image with (setf fdefinition), you
      can always reboot from a clean image, so don't be afraid to go ahead.
									  [17:10]
<ferada> pjb: mhm, thats an idea, but i can't just read a source file when it
	 has in-package at the start ..
<pjb> Yes, you can.  See IBCL.
<pjb> As long as it doesn't have cl:in-package.
<pjb> Also, with the stepper, I've noted one more reason why #'f is bad
      vs. (function f).  In the later case, it may be a different operator than
      cl:function, while in the former case that would require a different
      reader macro.  [17:11]
<ferada> pjb: okay thanks, i'll see how this goes  [17:15]
<H4ns>
       DATE;ELIGIBLE;AUDIT;NEW;NEW-NO-OTHER-PLAN;NEW-FROM-PLAN-1G;NEW-FROM-PLAN-1M;TERM;TERM-NO-REASON;TERM-03;TERM-07;TERM-22;TERM-BY-ABSENCE
									  [17:18]
<H4ns> 2012-03-01;591886;0;0;591886;0;0;0;0;0;0;0;0
<H4ns> 2012-04-01;615752;525485;0;83098;4523;2646;0;1;0;0;66401;66401
<H4ns> 2012-05-01;628363;574030;0;52178;1053;1102;0;4404;0;37319;0;41722
<H4ns> 2012-06-01;657773;586285;0;69755;794;939;0;5422;0;36657;0;42078
<H4ns> 2012-07-01;679988;612719;0;65661;604;1004;0;4919;0;40136;0;45054
<H4ns> fuck
* H4ns puts on the "paste idiot" hat
<Vutral> mhm  [17:21]
<H4ns> i think i need a clipboard timeout  [17:22]
<pjb> http://www.cs.berkeley.edu/~lmeyerov/projects/socioplt/papers/icse13.pdf
      says that language popularity is an exponential.  Therefore lisp should
      eventually win over.  [17:30]
<pjb> H4ns: once upon a time I had a command that would lisppaste when you
      yanked too much in an erc channel.  It bitrot however.  [17:31]
<pjb> I'm not in favor of "active libraries".
<pjb> The punishment for those are bitrotten code.
<Sgeo> pjb, I note that that survey talks about Sourceforge. I imagine that that
       might cause biases between the sorts of developers who use sf vs other
       services like github and bitbucket  [17:35]
<Sgeo> If there are any distinctions  between those groups, the data might be
       problematic
<mstevens> hello  [17:44]
<mstevens> what's the current hotness for lisp web apps?  [17:45]
<pjb> I don't know. How "hot" is http://www.google.com/flights/ ?  [17:46]
<mstevens> pjb: no no, not like that  [17:47]
<wuhen> clack
<Zhivago> Haven't they rewritten that in C++ yet? :)
<pjb> mstevens: hunchentoot?
<Cymew> That's a web server though, isn't it?  [17:48]
<mstevens> pjb: looks more promising
<Cymew> Isn't web apps frameworks and stuff like rails  [17:49]
<Sgeo> flights from are not currently supported
* Cymew realizes me might have gotten caught in a buzzword quagmire
<H4ns> Cymew: there is nothing that i'd call "hot"
<Cymew> Not that I knew either, really, actually...
<H4ns> Cymew: but part of it is that before you've grasped a frameworks' way of
       doing thing, you've rolled your own thing in lisp.  [17:50]
<mstevens> Cymew: well maybe, I was just sort of vaguely after something that'll
	   connect lisp and web pages, so that loops promising
<mstevens> (that=hunchentoot)
<sytse> pjb: is there any indication that lisp has become more popular over the
	last 10 years? :)
<Cymew> Give it a go
<H4ns> Cymew: the other part of it, of course, is that the lack of a "hot
       framework" is the reason why beginners are not dragged into lisp in the
       first place.
<pjb> sytse: yes.
<Cymew> H4ns: That or started drinking more seriously...  [17:51]
<pjb> sytse: that said, nobody here care about lisp popularity or lack thereof.
<H4ns> Cymew: or use something "sensible", like rails :)
<Cymew> >(
<Cymew> :)
<H4ns> Cymew: if you go that route, don't forget to write a blog post on how bad
       lisp has treated you :)
<Cymew> Hehe
<pjb> H4ns: perhaps we could have a nice web framework  library in quicklisp.
      That'd be just an asdf depending on hunchentoot and some html generation
      library.  [17:52]
<H4ns> pjb: the hard part is not slamming together the libraries, the hard part
       is writing a book "the lisp way" and then holding up to the "this is the
       only way" long enough for enough noobs to jump the bandwagon.
<H4ns> pjb: i guess you'd have no problems with the second part, so go for the
       first :)  [17:53]
<sytse> pjb: well, I do feel it's nice to have a growing community, that could
	help the community efforts (esp in the library department, in which CL
	is still a bit lacking I believe)
<pjb> sytse: then write the missing libraries.  [17:54]
<pjb> Personnaly, I'd have a hard time finding an empty library niche.
<sytse> yes, obviously, but noone can do that on his own
<H4ns> pjb: no.  every niche is filled with crap.
<H4ns> pjb: some contain gems, too.
* mstevens was in a vaguely lispy mood so I thought I'd have another go at
  learning it  [17:55]
<sytse> exactly H4ns
<H4ns> mstevens: by all means do!  i'm not trying to be negative, just realistic
       :)
<mstevens> H4ns: I found a fair bit of the negativity last time I had a go :)
<pjb> H4ns: yeah, right, you should blog about that: lisp libraries are crap.
<H4ns> pjb: but why?  i love lisp, but i hate propaganda  [17:56]
<mstevens> is pcl still the hotness when it comes to books?
<sytse> also, H4ns did not say 'lisp libraries are crap', on the contrary
<H4ns> pjb: like "we got libraries for everything".  true, if incomplete,
       undocumented, non-working counts into the "got"
<pjb> H4ns: Because this is dumb.  Lisp code is of the highest quality compared
      to other programming languages.
<pavelpenev> mstevens: yes, although land of lisp is also a pretty fun
	     book. Reading PCL is still obligatory though.  [17:58]
* sytse is halfway through a good getopt library with gnu-like (argp-like)
  features btw, could be that I finish that later this year
<pjb> sytse: that'll only be the fourth getopt lisp libraryâ€¦
<sytse> no, the first that's actually *useable* at all
<pjb> By the way, C's getopt is not usable either.  [17:59]
<mstevens> IIRC the problems I found last time were the ancientness of common
	   lisp, the state of libraries, and the lisp community (sorry!)
<H4ns> sytse: you see?  this persons "usable" is the next persons "crap", and
       this is worse in lisp than in other languages because lisp is
       multi-paradigm.
<pjb> Oh, enough of that crap.  [18:00]
<sytse> pjb: at least it is theoretically *possible* to write a good option
	parser with gnu getopt, this cannot be said about the extant libraries
	in CL
<H4ns> mstevens: instead of looking for the problems, you need to be looking at
       how lisp is great.  and if you don't, then use something else.  [18:01]
<sytse> yep.
<pavelpenev> mstevens: ancientness is a feature. In a way, the same is true for
	     the community(we need to scare away the hipsters :)
<mstevens> pavelpenev: I think it was "files" being strange and nonstandard that
	   discouraged me in particular  [18:02]
<pavelpenev> mstevens: you mean pathnames? Yes, they are a bit archaic, but in
	     practice, not a problem.
<pavelpenev> and they are standard, just not the unix standard :)
<ferada> where unix standard is "sequience of bytes"  [18:03]
<ferada> if you can't open a file, because the filename wasn't encoded properly,
	 thats very annoying
<ferada> other than that merge-pathnames is gold  [18:04]
<mstevens> In terms of community, I remember #lisp trying to tell me I was
	   insane for wanting to run my program from the command line rather
	   than opening a repl and running (start-it-all) or something.
<sytse> and that's the only good thing about microsoft crap I know: they did
	manage to postulate utf-16 encoding for filenames..  [18:05]
<p_l> sytse: because UCS-2, later UF-16 is NT's internal encoding  [18:09]
<p_l> "classic" strings have to be converted once they go into "NT land"  [18:10]
<p_l> so of course NTFS includes Unicode-based FILE "name"
      attribute... ergh. NTFS terms are kinda weird, sorry
* mstevens experimentally installs quicklisp  [18:11]
<sytse> p_l: I know, but that doesn't detract from the fact that it's good.
<p_l> sytse: I prefer Plan 9's "UTF-8 is the only accepted encoding". Windows
      allowed way too much cruft in name of backwards compatibility into system
      directly  [18:12]
<sytse> obviously all of the technical details about just about all of it are
	repulsive on windows, duh.
<sytse> and yes, plan 9 does it better
<sytse> I was just naming the one tiny thing I could think of that's good about
	windows nt ;-)  [18:13]
<p_l> sytse: there's quite a lot, but it's IMHO fragmented and boggled down
      under crap (or sometimes misconfigured by default, because if enabled,
      consumers complain)  [18:14]
<mstevens> (defun hello-world () (format t "hello world"))  [18:15]
<mstevens> hmm, I tried to install slime, but it doesn't seem to be able to eval
	   anything, which I'm sure is an important feature  [18:19]
<p_l> mstevens: probably missed (slime-setup '(slime-fancy)) ?
<H4ns> mstevens: you may want to follow a short tutorial like this:
       http://www.mohiji.org/2011/01/modern-common-lisp-on-linux/  [18:20]
<mstevens> I have (load (expand-file-name "~/quicklisp/slime-helper.el"))
<mstevens> And that seems to be loading fine  [18:21]
<mstevens> H4ns: oh, that's much more functional
<mstevens> I'd forgotten the M-x slime  [18:22]
<mstevens> I assumed I could just open a lisp file
<H4ns> mstevens: stop assuming for a while
<moore33> Is there anything special needed to integrate quicklisp and asdf? If
	  you've installed something with quicklisp, can you forever after use
	  it as a dependency in asdf definitions?  [19:39]
<stassats> quicklisp uses asdf
<moore33> Guess I'm unclear if quicklisp maintains a state of installed systems
	  for future invocations.  [19:40]
<stassats> i shouldn't to worry about anything  [19:41]
<stassats> shouldn't have
<stassats> bah
<stassats> s/i/you/
<stassats> just make sure that quicklisp is loaded in your init file  [19:42]
<moore33> So, (ql:quickload "spatial-trees"), and in the future I'm good?
<stassats> yes
<moore33> Very nice.
* moore33 pokes Xach.
<kmee> even better, if you create a system that depends on spatial-trees and
       other libraries, and you quickload it, it will load all the missing
       dependencies  [19:43]
<moore33> kmee: Nice!  [19:44]
<Xach> ahoy moore33  [20:13]
<moore33> Xach: I'm sure this is old news, but quicklisp is very cool. It's
	  making it easier for me to do some mcclim hacking.  [20:14]
<Xach> my worst fears realized!
* Xach hoped quicklisp would be used only for good
<moore33> bbl; lunch time
<Odin-> Xach: CLIM is not good, then?  [20:15]
<Xach> It is wicked  [20:17]
<ogamita> It is good.  It only needs some rejuvenation.  We need more lispers
	  working on it.  [20:19]
<antifuchs> wicked cool, definitely (:
<H4ns> it would have been nice!  [20:23]
*** PuercoPop (~PuercoPop@190.41.173.174) is now known as Guest75729  [20:26]
*** Guest75729 (~PuercoPop@190.41.173.174) is now known as PuercoPop420  [20:27]
<Xach> naryl: trivial-irc has been updated in its main bit  [20:32]
<naryl> Can you build it now?  [20:33]
<Xach> yes, builds fine
<Xach> naryl: he finally applied the pull request from last year
<naryl> Anyway you could contact karvus about further problems.
<naryl> right, mine one :D  [20:34]
* Xach feels the warm glow of new and updated libraries
<Xach> Sven van C10e said he will move his s-* libraries to github
<Xach> (he also said he doesn't do cl any more, just pharo smalltalk, but i'll
       take it anyway)
<naryl> Maybe he could do an s-exp aware diff and VCS inspired by Pharo? :)
									  [20:37]
<naryl> My earlier dreams about such system have been broken by... reader
	macros.  [20:39]
*** theos (~theos@unaffiliated/theos) is now known as Guest42013  [20:40]
<moore33> hey antifuchs  [21:02]
*** ogamita (~t@81.202.16.46.dyn.user.ono.com) is now known as pjb  [21:03]
<H4ns> naryl: reader macros break a lot of dreams
<H4ns> like "i could write this refactoring tool for cl"  [21:04]
<pjb> You can also just say no to reader macros.
<naryl> pjb: like #+
<H4ns> pjb: certainly.  i don't use them.
<pjb> After all, AFAIK, reader macros were only introduced as a mean to
      implement compatibility with older lisps.
*** PuercoPop420 (~PuercoPop@190.41.173.174) is now known as PuercoPop
<stassats> H4ns: do you use (?  [21:05]
<pjb> The standard lisp syntax has just been generalized under reader macros. So
      you're always use them.
<H4ns> pjb: they have involved into something that everyone feels like using in
       ther lisp learning experience.
<maxm> refactoring tools require rigid source code convention structure, written
       in stone
<pjb> On the other hand, I'm very happy with my #\[ reader macro to read
      Objective-CL code.
<madnificent> H4ns: albeit true, perhaps it's sane for some refactoring tools to
	      come with warnings like "reader macros not supported", a best
	      effort is often better than no effort at all
<pjb> Including #' ?  [21:06]
<maxm> if java allowed multiple top level classes per file, files for package
       could be anywhere instead of "dotted package path -> directory
       structure", Eclipse refactoring would not be possible
<pjb> Exactly: a lisp IDE or project manager can impose a file management
      scheme.  [21:07]
<pjb> Or said otherwise, can relieve the programmer from the bother of managing
      source files.
<madnificent> maxm: some goes for rails.  part of why it was relatively easy to
	      generate code was because the format was so rigid.  you knew it
	      would fail on edge cases, but in general it was good enough.
	      still, i don't see why a sufficiently smart system couldn't work
	      around it.  (also, lisp macro's are still a lot simpler on the
	      mind)
<madnificent> s/some/same/  [21:08]
<pjb> Now, given that reader macros exist and are fundamental to CL syntax, the
      conclusion is that you need to keep in a CL IDE, text snippets as source
      code instead of sexps.  (or both).  But otherwise it's rather as easy to
      deal with them than without.
<madnificent> pjb: there's no real reason why the reader macro couldn't be an
	      s-expression stating that there's a reader macro occuring on the
	      contained string.  perhaps that could work from a refactoring pov.
	      either case, good support for refactoring would require a decent
	      code-walker anyways.  [21:10]
<naryl> pjb: You can pack reader macros (and comments) into some â€œdon't look
	insideâ€ object and store only sexps. The contents of these objects are
	print out without change and refactoring tools... will have to assume
	they are side-effect free and move them around witout looking inside.
									  [21:11]
<naryl> (That's what I wanted to did for my graduation project but due to time
	constraints I didn't implement it)
<naryl> s/did/do/  [21:12]
<naryl> And reader macros were the only problem with storing code as s-exps.
<pjb> madnificent: there's one problem however: reader macros can read 0
      expression.  [21:24]
<pjb> So: (defun (\;-comment "Hi this is a function") fun (\#\|-comment "Hi
      another comment") (a b) (+ a b))
<pjb> that means that such sexps cannot be processed by the normal CL:EVAL or
      CL:COMPILE.  [21:25]
<pjb> naryl: yes, that's what I mean.  You have to keep around text source.  You
      can also keep around sexp source, but since you can just read the text
      source again.  Also notice that keeping sexp-source is problematic for
      closures: (let ((a 1)) (defun s (v) (setf a v)) (defun g () a))  [21:26]
<pjb> eval-when and other toplevel-preserving forms (progn, etc and macros
      expanding to them),  also require a wider scope sexp.  [21:27]
<madnificent> pjb: oh yeah, that's certainly true.  it was merely for allowing
	      the refactoring tools to work around them.  working with them
	      seems to be rather complex.
<pjb> If you keep text chunks as source, that can be made to work seamlessly.
<pjb> Furthermore, it may be easier to edit: you can easily split or write
      several functions at once, and when processed by the IDE, each toplevel
      form is separated into a different text chunk, as source for zero or more
      lisp objects.  [21:28]
<madnificent> perhaps you can extend the AST with a dual representation
	      indicating the chunks of source-code they match with.  that way
	      you know what you need to replace where when manipulating the
	      tree.
<madnificent> (and obviously, it helps with the s-expressions)  [21:29]
<pjb> In my view, you need to keep and manage the text chunks in a separate data
      structure, with references between it and lisp objects.
<pjb> See my notes about in:
      https://gitorious.org/com-informatimago/com-informatimago/blobs/master/common-lisp/lisp/ibcl-notes.txt
									  [21:30]
<j_king> (morning 'lisp)  [22:24]
*** PuercoPop (~PuercoPop@190.237.7.137) is now known as Guest54844  [22:25]
<pkhuong> maxm: that must be why the first refactoring browser was written for a
	  file-less environment.
*** Guest54844 (~PuercoPop@190.237.7.137) is now known as PuercoPop  [22:28]
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [22:45]
*** [SLB]` (~slabua@unaffiliated/slabua) is now known as [SLB]  [22:46]
*** sambio_ (~cc@190.57.227.107) is now known as sambio  [22:55]
<didi> Why does CFFI manual use a new class called `easy-handle' instead of
       adding the `pointer', `error-buffer' and `c-strings' into
       `easy-handle-type'? The manuals says `define-foreign-type' is a thin
       wrapper around `defclass'.  [23:51]
<didi> It seems to use this fact while defining `my-string-type' later.

[Fri Aug 24 2012]
<caoliver> Greets!  I was reading over the usual comp lang feeds today, and
	   diddled a bit with D. Fontain's code.  I ran into an oddity, and not
	   being an X86 guru, I've no idea why the lisp code is slower than the
	   C code.  [00:19]
<caoliver>  http://sprunge.us/YFVK  [00:22]
<Xach> the author's nick here is "dim"
<Fade>  bet pkhuong could answer that question.  [00:23]
<caoliver> Ok.  Still, after replacing the and with a simple (the fixnum...) the
	   loop is basically the same in the C as the lisp, but the C is eight
	   times as fast on my C2D under 64bit linux.  [00:24]
<Fade> not to put him on the spot or anything.
<caoliver> I'd expect he would.
<caoliver> Not that any of this is super super important, but I found it
	   surprising.  [00:25]
<caoliver> Fade: did anyone make a video of Reti's talk?  [00:26]
<Fade> I am not Fare. ;)
<caoliver> Err...  sorry.  Well now you know what shoe size my mouth is.  [00:27]
<stassats> caoliver: well, as i told yesterday, lisp code and c code is
	   completely wrong in that post
<Fade> two characters aren't enough for tab-complete in this namespace. :)
<stassats> sum of integers from 0 to (expt 10 10) is 66 bits, does not fit into
	   64-bit  [00:28]
<caoliver> stassats: Yes indeed.  Also, that C snippet uses 32bit ints, so of
	   course it's faster.  (Derp derp derp!)
<stassats> the code just overflows the int (sic, int, not even a unsigned long),
	   and the fixnum declaration for CCL makes it overflow it too
<stassats> so, only python makes a fare effort at adding bignums  [00:29]
<stassats> fair
<caoliver> Yeah.  SBCL blows chunks, and for stupid grins I turned safety off.
<stassats> so, the whole post is misinformation
<caoliver> Still, I'm surprised that four instruction loop seems so different
	   between the two.  [00:30]
<caoliver> stassats: I agree with you, but it was a morning's play.
<stassats> what if your compiler transformed that code into (/ (* max (1+ max))
	   2), would it be fair?  [00:32]
<naryl> hm...
<naryl> stassats: Would you do it for SBCL's loop? :]  [00:33]
* pavelpenev thinks the best way to make lisp fast is to figure out how to avoid
  having to compute at all. Or as Erik Naggum puts it: "what are you doing with
  that 20,000Ã—20,000
<pavelpenev>   double-precision floating point matrix you say you need to invert
	     _today_?"
<naryl> please? :]
<stassats> naryl: it'd be useless
<caoliver> The post was about microoptimizing naive algos.
<naryl> stassats: But then you can say that â€œSBCL does *a few* optimizations NO
	OTHER LANGUAGE DOES!â€  [00:34]
<caoliver> And he got several things wrong, but I'm just curious about the
	   difference I'm seeing.  (...q vs ... isn't it, nor is the alignment)
<naryl> Just for posts like the discussed one.
<pkhuong> caoliver: well, it's not macro op fusion... both loops are so tiny
	  that they're affected by random changes.
<pkhuong> ISTM it should fit in the loop cache, but who knows?  [00:35]
<caoliver> I'd expect over (expt 10 10) iters, that would get lost in the
	   underflow.
<caoliver> Would the register choice make any diff?  It's been a while since I
	   though seriously about x86 arch, but the accum use to perform
	   significantly different.  [00:36]
<stassats> you can try measuring (expt 10 9), it fits into 62 bits  [00:37]
<pjb> caoliver: mostly, if you want to compare lisp to C, you have to know C.
<pjb> That means, int a=b+c;/*in C*/ <=> (setf a (logand #xffffffff (+ (logand
      #xffffffff b) (logand #xffffffff  c))))  [00:38]
<pjb> s/int/unsigned int/
<pjb> Most lisp compilers will generate the same code as for C when you do that.
<pjb> char = (signed-byte 8), not character, etc.  [00:39]
<caoliver> Did you look at the sprunge?
<pjb> I only saw x86 assembler, which I don't read.  Try again with C and lisp.
<pjb> caoliver: more information at http://cliki.net/Performance  [00:41]
<pkhuong> caoliver: do you get the same result? Are you actually performing the
	  same number of iterations?
<caoliver> That's a very good question.  [00:42]
<caoliver> I'm trying to think of a was to find that out.  I'm guessing perhaps
	   not.
<pkhuong> ... print it.  [00:43]
<caoliver> s/was/way/
<stassats> naryl: do other languages optimize (expt -1 x) into (- 1 (* 2 (logand
	   1 x)))?  [00:44]
<pkhuong> for instance, the original post is completely bugged: 10^10 overflows
	  a 32 bit int, so it's actually doing 1410065408 iterations.
									  [00:45]
<stassats> the only correct and fair code there is in python  [00:46]
<caoliver> (herpderp-p :caoliver) => t  [00:48]
<caoliver> I forgot to include <stdlib.h> in my C prog, and atol() was being
	   treated as an 32bit int.  Now the lisp and C take the same time.
									  [00:49]
<caoliver> pkhuong: Thanks!
<stassats> it's important to measure the same things when doing silly benchmarks
* caoliver hangs head in shame.
<caoliver> To be blunt, I realized the OP had multiple problems with his code,
	   but I was trying to figure out what he was trying to do.  [01:00]
<caoliver> BTW: I don't read python.  [01:01]
* jasom tried again yesterday to get a gui toolkit other than ltk to work and
  again gave up after a few hours  [01:07]
<stassats> jasom: what os?  [01:08]
<jasom> stassats: linux 64-bit
<stassats> good
<stassats> have you tried commonqt?
<jasom> I have not
<stassats> you should!
<jasom> I didn't even look at qt bindings since most FFI to C++ is usually
	painful  [01:09]
<pkhuong> jasom: it's ok, someone else endured that particular pain for Qt.
									  [01:10]
<p_l> jasom: it works around it by serializing some Qt-specific patterns
<wbooze> commonqt works with ecl here
<wbooze> called eql
<wbooze> pretty good  [01:11]
<wbooze> hmmm
<p_l> jasom: CommonQT in exchange gets a way to do string lookups of Qt symbols
<p_l> wbooze: EQL is not CommonQT
<stassats> jasom:  if you're on debian, install libsmokeqt4-dev qt4-qmake
	   libqt4-dev
<wbooze> didn't try it with sbcl or cmucl yet
<stassats> cmucl?
<p_l> wbooze: EQL is based on inline C++
<wbooze> p_l: what is it then ?
<wbooze> aah
<wbooze> but it uses qt anyway.....
<stassats> jasom: and commonqt from quicklisp, and you're set  [01:12]
<wbooze> i just find the table cells double click behaviour odd.....
<jasom> stassats: is there a demo, or an application I can poke around in for
	it?  [01:13]
<stassats> jasom: there's a demo included  [01:14]
<caoliver> As a sometimes squeaker, I wonder: has anyone thought about using SDL
	   and running a complete genera style dev environment from within CCL
	   or SBCL rather than using Slime from outside?
<stassats> jasom: load qt-tutorial
<stassats> and then (qt-tutorial-14:main)
<p_l> caoliver: there's Climacs and Hemlock  [01:16]
<wbooze> well this is my beirc client i connected with....
<wbooze> uses mcclim
<stassats> caoliver: running the editor in the same image is prone to crashing
	   the whole thing  [01:17]
<wbooze> and climacs is an emacs like editor written in common-lisp which uses
	 mcclim too
<jasom> haha mcclim is the one I tried to get working yesterday
<caoliver> stassats: Yes you can saw off the branch you're standing on, so don't
	   do that.
<wbooze> i got it running too, but some features and keybindings are annoying...
<stassats> caoliver: don't do what?
<stassats> run into a mistake with safety 0? bogus ffi? heap exhaustion? bug in
	   an implementation?  [01:18]
<caoliver> stassats: Don't do crashy things with your image.  It's pretty easy
	   to bring Genera down as well.
<stassats> how can i absolve myself from such things? tell me a secret  [01:19]
<jasom> Ah yes, crash-never programming
<pjb> stassats: (declaim (optimize (space 0) (speed 0) (debug 3) (safety 3)))
<pjb> and don't use CFFI.
<pkhuong> stassats: process isolation.
<jasom> pjb: and don't run into any bugs in your lisp implementation  [01:20]
<pjb> Yes.
<jasom> or exhaust your heap, or your program stack or integer overflow
<stassats> pkhuong: well, i propose to keep the existing architecture, cl-slime
	   in different process communicating over network
<pjb> But I must say, nowadays CL implementations are rather bug free.
<stassats> pjb: you are not doing anything interesting then  [01:21]
<pjb> Some implementation even handle stack exhaustion nicely.
<caoliver> That you can die with safety 0 or calling out to an FFI isn't odd.
	   Those are DANGEROUS actions.  [01:25]
<stassats> so, just let it run in a separate process and crash however many
	   times it want  [01:26]
<caoliver> Sort of Erlang-ish, but there you go.  [01:27]
<caoliver> Still, I'd like an image I can live in much like Genera or Smalltalk.
<stassats> and i oftentimes restart the image to get a fresh environment
<caoliver> I try to get away from the toss it over a cliff and start again
	   philosph.  [01:28]
<stassats> i see no benefits in running an editor inside the same image
<caoliver> You hack the editor (careful) from within the editor.
<stassats> caoliver: i try to get things done fast and effectively
<caoliver> s/careful/carefully/  [01:29]
*** superflit_ (~superflit@75-171-201-114.hlrn.qwest.net) is now known as
    superflit
<caoliver> I make the assumption and anything is likely to need tweeking, and
	   I'd like to keep the knowledge base to do so as small as possible.
									  [01:30]
<caoliver> smalltalk tools in smalltalk.  Multiple images in case I get stupid.
									  [01:31]
<stassats> how is the air in your ivory tower?
<caoliver> Well oxygenated.
<caoliver> ;-P
<caoliver> Look.  In the last 15 years or so, the desire to monetize the i'net
	   has left us maintaining much tech in the worst of taste.  Maybe we
	   can in our not-so-copious spare time strive for a better end.
									  [01:32]
<stassats> doing impractical things for philosophical reasons doesn't smell like
	   a better end  [01:34]
<caoliver> vis. Alan Kay on instrumental vs. non-instumental learning and the
	   value thereof.  [01:35]
<caoliver> Gotta go.  Thanks for all the help folk.  'later.  [01:39]
<naryl> stassats: An s-exp or text editor in the separate process is ok. An IDE
	(like SLIME) is less than practical though. IMO.  [01:42]
<naryl> We already run the compiler, debugger, half of the IDE and the software
	being developed in the same process.  [01:43]
<madnificent> if it cannot run in the same process, something is wrong in the
	      design.  you shouldn't want to run it on a production server, but
	      during development, i don't smell anything fishy  [01:44]
<stassats> naryl: neither of which matter for the user if they crash and are
	   restarted  [01:45]
<stassats> having to lose all the open files, context, and so on, after crashing
	   is what's annoying  [01:46]
<naryl> stassats: If the editor crashes and restarts it will matter whether it's
	in the same process or not.
<stassats> the editor doesn't need to crash
<stassats> you don't modify the code of the editor when you develop third party
	   programs, it will be well tested and debugged  [01:48]
<naryl> So it doesn't matter if it's in the same process or not.  [01:49]
<naryl> Ah, I'm spoiled by Erlang.
<stassats> what? man, i'm not gonna repeat everything for the second time!
<naryl> stassats: third party can take the editor with it.
<naryl> *third party program  [01:50]
<stassats> it can't, it runs in an another process
<naryl> If it runs in the same process.
<stassats> that's why you don't run it in the same process
<naryl> After a few monts of Erlang I forgot that a module can crash a
	completely unrelated another one. :D
<naryl> It actually happened to Erlang. Once. Out of memory.  [01:51]
<stassats> processes are such modules
<naryl> for CL and most other languages.
<stassats> and besides, there are just no benefits for running the development
	   image and the editor in the same image  [01:54]
<pjb> minion: memo for caoliver: have a look at ibcl
      http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/ibcl/index.html
									  [01:57]
<minion> Remembered. I'll tell caoliver when he/she/it next speaks.
<naryl> pjb: Do you agree that there are no benefits?  [01:58]
<naryl> I can think of a few but stassats is too intimidating :)
<stassats> naryl: so, what are they?  [02:01]
<stassats> let's debunk them!
<stassats> (granted there should be functionality to modify the editor itself)
									  [02:03]
<pjb> naryl: the notion of process has been introduced on unix because it was
      programmed in C.  It is useless when you write your system and tools as
      well as your programs in programming languages with controlled
      environments.  [02:04]
<moore33> . o O ( What could go wrong if an updating-output record never
	  updates? )  [02:05]
<pjb> Now, you can have the editor separate from the program process, thanks to
      swank/slime, but having the editor not written in Common Lisp is a major
      inconvenience.  Notably to analyze reader macros, but also macros, you
      need to execute the program in the editor.
<stassats> execute malicious code just by opening a file? great  [02:06]
<pjb> naryl: I wrote a CL reader and a CL package system to be able to read CL
      source files without interning symbols, ie. without loading the program,
      but this doesn't work in practice because of reader macros.
<pjb> stassats: anyways, you can do that in emacs with file local variables.
<stassats> pjb: it asks you whether you want to apply them  [02:07]
<pjb> stassats: and the system asks you whether you want to load a file or do
      something else.
<naryl> stassats: Well, there was another option for my graduation project's
	architecture. Which was running the development system and all tools in
	second lisp-process. It controlls the s-exps and the first one executes
	the code. But this approach would bring problems with side-effectey
	macros in addition to all the problems with reader-macros I already had.
<pjb> Indeed, you still need to load a part or the program, sometimes sizeable.
									  [02:08]
<stassats> naryl: what problem with macros? you can execute and query them in
	   the executor process  [02:09]
<pjb> you may want to macroexpand the macros to identify the various kind of
      arguments, what's data, what's code, so that you can colorize and indent
      them adequately.  [02:10]
<stassats> and the authors of macros with side-effects should be ostracized
<stassats> pjb: well, macroexpand them in an another process, what's the
	   problem?  [02:11]
<pjb> Perhaps, but it is often nice to write macro with compilation environment
      side effects.
<pjb> stassats: it's more complex, for nothing: again, we're not speaking of C.
<stassats> more complpex? instead of EVAL you have REMOTE-EVAL?  [02:12]
<pjb> Have a look at swank/slime  I call that more complex.
<moore33> pjb: compilation environment side effects should happen in the macro
	  expansion, not the macro code... Not that I necessarily agree that the
	  editor should be in a seperate process.
<stassats> i had a look at swank/slime, it's not more complex  [02:13]
<naryl> stassats: I think it takes three stack frames to remote-eval. Are they
	empty?
<pjb> moore33: the macro expansion never has any compilation environment
      effects!  By definition, it can only have run-time effects!
<stassats> naryl: i don't understand the question  [02:14]
<naryl> nm
<moore33> pjb: uh... (eval-when (:compile-toplevel)). Macroexpand defun
	  sometime.  [02:15]
<stassats> there's no conceptual complexity when evaluating your code locally or
	   remotely, yes, the remote evaluator should be first written, but it's
	   trivial and needs to be done anyhow, to connect to truly remote
	   environments
<pjb> moore33: of course, there's also eval-when which allows random effects at
      any time you want.
<pjb> stassats: again, that serves no purpose: when you have a bug in your
      program, it signals a condition and that's it: there's no consequence for
      the editor functions.  [02:16]
<stassats> this is pointless, you're talking about some theoretical magically
	   ideal code, i'm talking about real world experience  [02:17]
<didi> Would Emacs be an example of this "editor and program in the same
       process" you are talking about?
<moore33> didi: Yup.  [02:18]
<didi> Hum... I kinda love that.
<stassats> didi: yes, emacs lisp doesn't have unsafe features and doesn't have
	   ffi
<didi> I see.
<stassats> i crash my CL implementation irrevocably all the time  [02:19]
<anvandare> how do you manage that?
<pjb> stassats: last time I had a lisp implementation crash on me, it was at
      least 7 years ago, for a bug in clisp.
<pjb> sbcl save-lisp-and-die is much more inconvenient than the possibility of a
      crash of a CL implementation.  [02:20]
<moore33> stassats: You would assert that you can never get emacs into a state
	  where it freezes or is otherwise unusable?
<stassats> moore33: far less often  [02:21]
<pjb> moore33: never.
<oGMo> heh, i've had 1.0.58 exploding on me, had to go back to 1.0.57
<pjb> At least less often than you have to reboot linux to install new versions
      of the kernel or new drivers.
<jdz> pjb: i've had emacs process just die on me
<jdz> poof, and it's gone
<stassats> moore33: but i don't write in emacs lisp that much  [02:22]
<didi> jdz: It does not "die". It just leave you to do its own things.
<didi> s/leave/leaves
<stassats> anvandare: as i said previously "run into a mistake with safety 0?
	   bogus ffi? heap exhaustion? bug in an implementation?"  [02:23]
<pjb> I have emacs instances with an uptime close to 690  days.
<stassats> used daily?  [02:24]
<pjb> stassats: never run with safety 0.  Avoid ffi like the plague.  Don't
      write scheme code in CL.  Use a stable implementation.
<stassats> pjb: don't give bad advice?  [02:25]
<pjb> stassats: not used daily, but often enough.
<oGMo> pjb: and get nothing done
<jdz> oGMo: except reimplement stuff that's already done
<pjb> oGMo: well, http://gitorious.org/com-informatimago is done like that.
      That must be nothing.
<moore33> If your Lisp has a good chance of crashing, due to your own efforts or
	  its instability, then of course it's no fun to run the editor in that
	  image. Not everyone is faced with that  situation.  [02:28]
<stassats> so, you're advocating limiting the amount of things that can be done
	   in CL just because you are afraid of crashing?
<stassats> i'm not afraid of crashing, but i don't want it to harm me
<pjb> I'm advocating controled environment.
<pjb> Even with separate processes it's no fun crashing!  [02:29]
<pjb> It's a silly solution (well it may have been practical when writing unix
      on a PDP-7, but it's ridiculous nowadays).
<stassats> moore33: you make it sound like running separate process is
	   excruciatingly painful
<stassats> processes  [02:30]
<pjb> Not excruciatingly, but it's painful.
<pjb> It's much nicer to work inside emacs.
<stassats> if you're pjb
<stassats> not everyone is pjb
<pjb> If it wasn't we'd be using vim, sed and awk, instead of emacs.
<pjb> stassats: are you a vim user?  [02:31]
<stassats> another nonsensical question?
<oGMo> heh
<stassats> this discussion is pointless
<naryl> pjb: If you're using vim you don't need sed and awk.  [02:32]
<pjb> stassats: you should read the Unix Hater Handbook.
<moore33> stassats: I don't really care very much. I was involved with some of
	  the climacs effort. I also think slime has done an impressive job
	  emulating the functionality of more integrated environments.
<pjb> naryl: the most useful command of vi is :!
<moore33> pjb: For the comedy value :)
<naryl> stassats: You should read it just for fun anyway :D
<stassats> i have read it and it's irrelevant to this discussion  [02:34]
<pjb> Then go read about EROS too. http://eros-os.org  It's another example of a
      system without separate address spaces.  It's safe, because it's
      capability based.  [02:36]
<stassats> do you use it on your desktop?
<oGMo> it really doesn't matter. at the point where you hit the network cable,
       you have to communicate somehow .. safety isn't the whole story  [02:37]
<oGMo> or "you have to deal with multiple processes somehow"  [02:38]
<stassats> and you can read about the mars rover, how they run many threads for
	   different tasks
<pjb> stassats: sure, they wrote it in C the idiots!
<oGMo> yeah, lost opportunity .. having a slime session open to mars would be
       kinda neat  [02:39]
<pjb> oGMo: on the other hand, given how Nasa sends commands to the REPL (and
      the 0:40 to 1:20 round trip), a REPL with sondes doesn't feel so
      interactive.  [02:45]
<pjb> oGMo: watch http://www.youtube.com/watch?v=_gZK0tW8EhQ  [02:46]
<stassats> are they doing interactive development?
<didi> I read somewhere that Nasa once used the REPL to debug a problem
       remotely.
<pjb> didi: watch http://www.youtube.com/watch?v=_gZK0tW8EhQ
<stassats> "let's test this function. 14 minutes later, oops, it drove off a
	   cliff"
<pjb> People, you can read and follow links also of message addressed to
      specific persons!!!  [02:47]
<pjb> stassats: well that explains why they take 2 weeks to drive 300 meters!
<didi> pjb: Yeah, right. I listened instead. Great talk.
<stassats> rickroll? no thank you
<oGMo> pjb: yes i know :p
<didi> pjb: He doesn't seem to like the operators though. ;^)  [02:48]
<vsync> '"the one thing causing problems with space explorations is Lisp on the
	probes" and from that point on Lisp at JPL was dead'
<vsync> reading that story still makes me twitch
<anvandare> maybe it was for the best, a lisp-controlled probe would only lead
	    to v'ger :>  [02:49]
<pjb> Lisp on the probes isn't a problem: it's a solution.
<pjb> They would have been toast if it had been written in C.
<didi> pjb: But following links addressed to other people wouldn't be impolite?
       I mean, it's their links, not mine.
<pjb> only if it was in /msg oGMo.  [02:50]
<didi> oic
<stassats> clisp is using a c compiler, did you know?  [02:51]
<didi> pjb: Speaking of CLISP, are there plans to release v2.50?  [02:52]
<pjb> didi: when it's ready.  [02:53]
<stassats> didi: clisp isn't vain and doesn't need to have releases every 5
	   years
<pjb> stassats: I know.  Nowadays I use mostly ccl.
<didi> No, not Debian Stable, CLISP.
<stassats> pjb: and its kernel is written in C and assembly  [02:54]
<pjb> stassats: I know.  Nowadays I use mostly ccl.
<didi> Debian's version apparently have some issues its dynamic modules.
<didi> *with its
<pjb> stassats: but if that's what you meant, it doesn't use a c compiler to
      compile lisp code, it has its own lisp compiler written in lisp.  Perhaps
      you're confusing with ecl.
<didi> Also, /me is excited about ccl coming to Debian.  [02:56]
<moore33> pjb: CCL does have a kernel written in C and assembly, though the
	  compiler is written in Lisp as you say.  [03:01]
<moore33> How does one set the print length for output in the Slime sldb buffer?
									  [03:03]
<pjb> moore33: it's not a "kernel" that ccl has written in C.  More like a few
      unix interface functionsâ€¦
<wbooze> man print-length  [03:04]
<specbot> Sorry, I couldn't find anything for print-length.
<pjb> moore33: In ~/.swank.lisp, have a look at
      http://paste.lisp.org/display/123730
<stassats> pjb: it calls itself a kernel, and it includes a garbage collector
	   and stuff
<moore33> pjb: Thanks.  [03:05]
<wbooze> it's here http://clhs.lisp.se/Body/v_pr_lev.htm
<pjb> Yes, a lot of implementations write their GC in C, for absolutely no valid
      reason.
<stassats> wbooze: s/man/clhs/  [03:06]
<stassats> pjb: there's no *sldb-printer-bindings* variable anymore  [03:07]
<stassats> and i welcome you to peruse this
	   http://jsnell.iki.fi/blog/archive/2005-12-21.html on the "GC in C"
	   theme  [03:10]
<wbooze> i somohow assumed gc's would be asm level all....  [03:11]
<wbooze> somehow*
<[6502]> hello... is it possible to have emacs indenting a list beginning with
	 #' like if it was a defun? I mean indenting (#'square (x) ...) like if
	 it was (defun square (x) ...)  [03:23]
<stassats> of course it is possible, it's emacs, it's programmable  [03:24]
<[6502]> stassats: I bet that if someone asks you if you know what time is it
	 your answer is "yes, i know"  [03:25]
<pjb> Indeed.  [03:26]
<sellout42> [6502]: Does anybody really know what time it is?  [03:27]
<[6502]> i actually have a few customizations in my .emacs (e.g. (put
	 'with-open-file 'lisp-indent-function 1) ) ... but i found them on the
	 net and the documentation for how it works is not that clear for me
<pjb> read the emacs manual.
<stassats> [6502]: well, read the slime-indent contrib  [03:28]
<stassats> [6502]: if i knew how to do it, i would tell, you, but i only know
	   that it's possible
<stassats> slime-cl-indent  [03:29]
<[6502]> not really related... i've been working a bit on a pretty printer for
	 lisp code... it's not that easy. and this makes me wonder if it should
	 be considered as an alarm sign that lisp syntax is not that great after
	 all
<Bike> [6502]: you could look at the one in lisp.  pprint dispatch table and
       all.
<pjb> Reader macros have complexified the situation indeed.  But they're
      necessary to be able to read legacy lisps.
<stassats> can i go about without #\( reader-macro?  [03:30]
<[6502]> pjb: of course not even considering reader macros except for standard
	 ones like quoting or backquoting
<[6502]> pjb: just printing labels or do forms in a pretty way is annoying
									  [03:31]
<Bike> [6502]:
       e.g. http://www.lispworks.com/documentation/HyperSpec/Body/22_bb.htm
<stassats> [6502]: making pretty things is not easy, you can ask the Renaissance
	   painters
<didi> Nice... hours because of a missing () in a defclass... Oh well.  [03:32]
<stassats> Bike: it's just a method of printing, you still have to supply the
	   actual rules  [03:33]
<Bike> i know, but it's helpful.
<didi> Yay, no crashing! Awesome.
*** cpt_nemo_ (cpt_nemo@2a01:4f8:130:62a2::7) is now known as cpt_nemo  [03:38]
<didi> Does anyone use those page marks (^L)? I'm thinking of using them.
									  [03:43]
<sellout42> didi: I've tried it a couple times, but always end up just making
	    them separate files.  [03:44]
<stassats> i just use ;;; to separate things
<sellout42> Things like ASDF, where having a single file is a significant
	    feature, might get some value out of ^L  [03:45]
<moore33> pjb: What legacy lisps do you have in mind? I thought that reader
	  macros were for extending syntax, domain specific languages, etc.
									  [03:47]
<didi> Does `unwind-protect' calls its `cleanup-form' even if you do a C-c C-c
       with SLIME?  [03:52]
<Xach> didi: yes
<didi> Xach: Awesome.
<Xach> C-c C-c in my lisp signals an interactive interrupt condition, which is a
       condition like other conditions  [03:53]
<didi> Uh, that's nice.
<stassats> didi: not if you continue  [03:54]
<Xach> That is an important point  [03:55]
<didi> stassats: Right.
<stassats> and not until you abort, of course
<stassats> or do some other kind of NLX
<dim> pkhuong: many thanks for your follow up to my stupid post  [04:04]
<dim> pkhuong: in the PostgreSQL community we use to say that we can get your
      SQL query as fast as you want it to be if you don't care about the result
									  [04:07]
<stassats> dim: there's an O(1) solution for this, so you can be fast & correct
<dim> true  [04:08]
<[6502]> There's always an O(1) solution
<dim> I'll try to have a follow up entry where I'm not trying to be stupid that
      hard :)
<dim> mmm, that's lots of tries
<dim> ok, gn guys, see you  [04:09]
<stassats> [6502]: not true
<pkhuong> stassats: log n, really ;)
<stassats> unless you have an infinite amount of memory and can precompute all
	   possible inputs  [04:10]
<stassats> of course, the amount of all possible inputs may be infinite too
									  [04:11]
<[6502]> stassats: any code you write for a computer in this universe either is
	 an infinite loop or it finishes in a finite < M amount of time, no
	 matter what is the instance of the problem  [04:13]
<[6502]> with an upper bound for M being the busy beaver number of the number of
	 atoms in the universe  [04:14]
<stassats> and what are you trying to tell me?  [04:15]
*** ASau`` (~user@89-178-169-252.broadband.corbina.ru) is now known as ASau
<[6502]> stassats: that I've some confusion in my head about the true meaning of
	 O(...) (among other things)
<stassats> i'd welcome an O(1) precise algorithm for factorials, which doesn't
	   use lookup tables  [04:17]
<sea4ever> Hmm..an O(1) algorithm for factorials without lookup tables..
<sea4ever> Does it have to produce the correct answer 100% of the time?
<stassats> yes, you can't use Stirling's formula  [04:18]
<pkhuong> trivially impossible: you need log(n) time just to read the input.
									  [04:19]
<[6502]> for example.. the input here is a number. What does it mean to be O(1)
	 independent on the number? You cannot even read a number of n bits of
	 precision in O(1)... Or is any processing of any number with any number
	 of bits of precision considered a constant?  [04:20]
<sea4ever> :( I was trying to joke. I was gonna say: "(return 1)", it's only
	   right sometimes, but it's very fast when it is right.
<stassats> imagine it's already read
<[6502]> the output will have some bits too, dependent on the number of bits in
	 input  [04:21]
<stassats> imagine we don't count the output
<pkhuong> stassats: that makes no sense. Any constant time algorithm can only
	  depend on a constant number of bit in the input.
<stassats> pkhuong: just don't count the time it takes to read the input  [04:23]
<oGMo> [6502]: right, a O(n) algorithm is also O(n^2), but that's not typically
       useful  [04:24]
<[6502]> oGMo: busy-beaver(number-of-atoms-in-the-universe) is just a fixed
	 number, big for sure... but just a number. And it's just theoretically
	 impossible to write any algorithm in this universe that will take more
	 steps than that number but terminates (it's the definition of busy
	 beaver)  [04:26]
<pkhuong> stassats: please think about this.
<oGMo> [6502]: i don't think that's relevant
<stassats> pkhuong: i know there's no O(1) for factorials, that's the point
									  [04:27]
<[6502]> oGMo: it means that any algorithm you can write is O(1)
<oGMo> [6502]: no it doesn't
<[6502]> oGMo: or loops forever
<pkhuong> stassats: what's that about not counting the time to read the input
	  then? That makes no sense.
<Euthy> Why does the number of bits of input matter?  [04:28]
<pkhuong> Euthy: because that's how time complexity is usually measured.
<oGMo> Euthy: it's part of the input size in this case. or it might be
<stassats> pkhuong: because i don't want to measure it, the time it takes to
	   read it doesn't change if i change the algorithm  [04:29]
<oGMo> you could however specify the factorial function only take N-bit input,
       and count read time as the constant factor
<oGMo> er, k-bit input, let's be less confusing
<oGMo> i.e., it takes a 32-bit number, no more  [04:30]
<Euthy> I don't really know O notation, but don't you have to define what is
	constant for it to make sense?
<pkhuong> stassats: you're not making any sense.
<[6502]> then that thing is O(1)
<oGMo> Euthy: only if you're being pedantic ;)  [04:31]
<stassats> pkhuong: that's just what i want to measure, however much sense does
	   it make
<Euthy> I don't know what I'm talking about here, but isn't this 6502's
	confusion?
<pkhuong> stassats: what's "read time"? One traversal over the input? Are you
	  trying to say "streaming complexity"?  [04:32]
<stassats> i don't what's read time, i'm not concerned about
<stassats> it
* [6502] liked that in TAOCP there no talking about O(n^2) or stuff like
  that. The analysis say things like "this algorithm takes 3n^2+7n+37 cycles"
<oGMo> [6502]: that's not how time complexity works
<Euthy> [6502]: Doesn't TAOCP use a specific language?
<oGMo> sure, but .. that
<[6502]> Euthy: a specific processor... all code is assembler MIX  [04:33]
<oGMo> and beyond n^2 it doesn't matter so much .. please study time complexity
<Euthy> [6502]: So isn't that analysis based on that architecture?
<pkhuong> I don't see how one can answer to the fact that a constant-time
	  algorithm can only depend on a bounded number of bit in the input with
	  "just don't count the time it takes to read the input." This isn't
	  about reading anything, but pure information theory.
<stassats> pkhuong: i have a binary number already stored in memory, i want to
	   compute its factorial, is that streaming complexity?
<Euthy> [6502]: The O being defined in relation to it.  [04:34]
<oGMo> pkhuong: the time it takes to read the input never varies if it's a
       fixed-size input. therefore it's part of the constant factor
<stassats> pkhuong: if reading bothers you that much you can set the size of
	   input to 64-bit
<[6502]> O(...) thinking is a wonderful tool for reasoning on practical terms,
	 and indeed it's the first thing I check when interviewing
	 someone... however I'm confused about the theoretical definition
<oGMo> pkhuong: it would indeed be valid if you were defining the algorithm to
       take an unbounded integer, for instance
<oGMo> [6502]: if you're not familiar with even this much, you shouldn't be
       asking interview questions about it :p  [04:35]
<pkhuong> stassats: that's trivially O(1) in regular, bit, complexity.
<stassats> pkhuong: and i want to know how?  [04:36]
<pkhuong> If you want to use another model, you really ought to specify that,
	  especially when factorial so quickly overflows fixed-width integers.
<[6502]> O(n) without having n going to infinite doesn't make sense to me (from
	 a theoretical point of view). if n doesn't go to infinite then
	 everything is O(1)
<Euthy> [6502]: What kind of machine are you talking about?
<oGMo> [6502]: no, no, no  [04:37]
<pkhuong> stassats: there's no asymptotic here. The bit complexity model is
	  ill-equipped to consider the question you're interested in.
<stassats> wait, i actually don't want to know it
<anvandare> infinity isn't a normal behaving mathematical number
<anvandare> *object
<[6502]> especially in javascript :-)
<stassats> all i wanted is to trying to prove that not everything O(1) by
	   contradiction
<pkhuong> stassats: you failed when you specified that your input were
	  fixed-size.  [04:38]
<oGMo> it's simple definition .. time complexity isn't about the _amount_ of
       time it takes, it's about the number of operations relative to input size
									  [04:40]
<[6502]> for example, do you know that there is an easy exact mathematical
	 formula that given n returns the n-th prime number, in increasing
	 sequence?
<[6502]> it's not philosophically worse than the formula for the area of a
	 circle
<oGMo> thus trivially a (loop for i below n do OP) loop is O(n) as the
       operations vary linearly with the input  [04:41]
<Euthy> Is this correct?: Saying everying is O(1) is analogous to saying every
	object in the world is 1 long.
<oGMo> this is _basic definiton_ here, criminy
<Euthy> s/everying/everything/
<[6502]> Euthy: O(1) means computing is bounded by a constant, not by 1
<stassats> oGMo: careful, it might not be formal enough, and this is #lisp
*** s0ber_ (~s0ber@114-36-227-19.dynamic.hinet.net) is now known as s0ber
<[6502]> Euthy: if the input is bounded then clearly this is true  [04:42]
<oGMo> stassats: heh
<Euthy> [6502]: I might be misunderstanding you but I could just as well have
	said 42 long.
<oGMo> let's not even bring up Theta and Omega :P  [04:44]
<pkhuong> [6502]: complexity models are created to analyse and understand how
	  programs behave in the real world (or to preserve academic
	  positions). There's most probably a bounded number of bits in the
	  universe, but asymptotic analysis is still useful. Your stance, while
	  technically correct, is practically useless.
<oGMo> [6502]: and, no, O(1) means that the _number of operations_ in the worst
       case does not vary based on the input  [04:45]
<[6502]> pkhuong: that's exactly my position... O(n) is ok for practical but
	 formally questionable reasoning
<pkhuong> [6502]: what? It's formally very well defined.
<stassats> well, the difference in the recent example, (loop for i to n sum i)
	   and (/ (* n (1+ n) 2) is pretty significant  [04:47]
<[6502]> pkhuong: yes, but talking about algorithms that cannot be implemented
<anvandare> all algorithms can be implemented  [04:48]
<[6502]> pkhuong: O(n) requires infinite to make sense
<pkhuong> One might say that the hypothesis of unbounded storage is obviously
	  irrealistic and brings the whole edifice down. Yet, it's a useful
	  abstraction, and, within that design choice, there is no formal issue.
<[6502]> pkhuong: yes... it is very useful in practice. But formally any real
	 algorithm you will implement will be O(1), because n, in the real
	 world, cannot go to infinite  [04:50]
<pkhuong> no, because formally we do have unbounded storage.
<anvandare> [6502]: the point of O notation is algorithm comparison  [04:51]
<pkhuong> You simply choose to build your analysis on a useless model and charge
	  others of being formally wrong. Yet these models are very well defined
	  and exhibit no formal weakness.
<[6502]> anvandare: abstract algorithms, not concrete ones
<anvandare> o_O?
<pkhuong> Landau notation was invented to classify functions...
<Euthy> [6502]: (define (foo lst) (when (not (null? lst)) (foo (cdr lst)))) <-
	How is this O(1)  [04:52]
<[6502]> Euthy: on a 32 or 64 bit machine?
<Euthy> What does it matter?  [04:53]
<pkhuong> [6502]: bit complexity is not defined on such abstract machines.
<[6502]> pkhuong: exactly... Knuth didn't use O(n^2) on TAOCP, but things like
	 max(170, 19n^3+7n^2+31n+7) with 0 <= n < 65535 for study algorithm
	 performance  [04:58]
<pkhuong> [6502]: and that precision is now useless.  [04:59]
<[6502]> for practical reasoning for sure
<Euthy> [6502]: How is my foo O(1)?
<pkhuong> It certainly doesn't tell me why the bit complexity model is formally
	  questionable.  [05:00]
<[6502]> pkhuong: it's not questionable in the abstract (with infinite computers
	 of inifinite resources), but it's questionable when it's applied to
	 real concrete implementations. It's not questionable for its utility
	 (it's a wonderful tool for reason quickly about these issues) but it's
	 imo formally questionable, because on real computers n doesn't go to
	 infinite  [05:02]
<[6502]> that's the confusion in my mind about the issue  [05:03]
<pkhuong> Formally questionable out of the formal world. Try this: a different
	  formal model could better correspond to the performance
	  characteristics of practical systems.
<[6502]> pkhuong: that's exactly the point. you could build a real MIX system
	 (i've heard someone did, using FPGAs), and the formal counting done by
	 knuth would be correct on that real implementation. The formal counting
	 done by O(...) theory just talk about computers that cannot exist.
									  [05:05]
<[6502]> still a wonderful tool, however...  [05:06]
<pkhuong> that's not what you convey when you write that the bit complexity
	  model is formally questionable.  [05:07]
<[6502]> I just fail to see how can you formally apply that model to real
	 programs. The hypothesis needed (infinite) just doesn't hold..
									  [05:08]
<pkhuong> it's an abstract model. It's not meant to be applied on real programs.
<Euthy> [6502]: Why did you ignore my question?  [05:09]
<[6502]> Euthy: if your system has 32-bit addressing, do you think that that
	 function could loop (recurse) more than 2**32 times?
<[6502]> Euthy: without looping forever in a circle chain of conses, that is
									  [05:10]
<Euthy> Ah. Now I think I see what you're talking about.  [05:11]
<[6502]> Euthy: any program on any finite computer will either 1) run forever,
	 2) terminate after a number of steps that smaller of a constant that
	 it's dependent on the size of the computer  [05:12]
<[6502]> Euthy: the maximum number of steps for a given size n is called n-th
	 busy beaver number  [05:13]
<oGMo> yes, and that's precisely useless when talking about algorithmic time
       complexity, so what's the point
<oGMo> "any program will either stop or not stop, so bubble sort is just as
       efficient as merge sort"?  [05:15]
<stassats> oh, that's how programs are keep getting slower, the developers are
	   thinking "ah, that's gotta terminate before the heat death of the
	   universe, good enough"
<oGMo> stassats: hehe
<oGMo> stassats: "and if we don't, no one will be around to file a bug"
<sea4ever> omg stassats, you signed an NDA!! You bastard!  [05:16]
<sea4ever> Stop giving away our corporate secrets!
<sea4ever> :\ this is how we save costs on developers
<stassats> as i think about it, why write programs at all, the user can do it
	   manually too, he will be done sometime before he dies  [05:17]
<oGMo> well there's also no need .. any bit can be either 0 or 1. any answer is
       composed of bits. therefore, randomly picking 0 or 1 is a constant-time
       operation to find a given bit of the result of any operation with 50%
       success, which is pretty good. so all we need is a coin.  [05:19]
<sea4ever> oGMo, that isn't entirely true.. if you want to decide on an outcome
	   that has a probability equal to a power of N, where N is relatively
	   prime to 2, you can't do it in bits in constant time.  [05:20]
<sea4ever> N.B. Decide on one of {A,B,C} with a 2-sided coin in constant time.
									  [05:21]
<oGMo> sea4ever: first off it's horrifically wrong, but i did say find _a given
       bit_, not all of them
<sea4ever> (Where the probability of A,B,C is evenly distributed)
*** ghast`` (~user@host83.190-30-155.telecom.net.ar) is now known as ghast
									  [05:22]
<didi> Nice, I think I understand CFFI sufficiently now to not crash Lisp
       constantly. Now, is it possible to use some kind of mechanism to clean
       allocated objects? CFFI has some, but none that would operate
       automatically. Maybe something like `trivial-garbage'?  [05:39]
<p_l> didi: trivial-garbage had, iirc, finalizer API, which you can use to call
      apropriate free() routines  [05:41]
<pjb> didi: there are some with- macros.
<didi> p_l: That's what I'm thinking, although I've never saw `trivial-garbage'
       in my life. Just spotted the name.  [05:42]
<didi> pjb: There are, but I went the object trail and I don't know how to
       reconcile it with the with- macros.  [05:43]
<pjb> Flanly, you'd be better off writing a C compiler in CL and compiling your
      C libraries with it, so that memory can be controlled by your CL
      implementation.
<pjb> Otherwise, the idea is not to keep references to C objects.  Build Lisp
      objects with their data.  So that you only need to allocate memory
      locally, and with- macros can free it after the ffi call.  [05:44]
<didi> pjb: The problem is that the library is event based, so I can't just call
       something and get the result.
<didi> Maybe I can, with each `make-instance', register each object in a global
       hash-table and clean them when the mail loop exits.  [05:47]
<didi> Well, I'll have to think about it.
<stassats> didi: what library is that?
<didi> stassats: gtk
<stassats> i see  [05:48]
<stassats> what happened to other gtk libraries?
<stassats> or commonqt?
<didi> I'm just trying this now.  [05:52]
<stassats> trying to write a new cl gtk library?  [05:53]
<didi> Nope.  [05:54]
<stassats> good
<didi> I know.
<stassats> didi: but what are you trying then?  [05:57]
<didi> stassats: Just playing around.  [05:58]
<stassats> didi: do you know about finalizers?  [05:59]
<didi> stassats: No, but they sound useful. What are they?  [06:01]
<stassats> hooks into garbage collector called when an object is about to be
	   collected
<didi> Nice.
<didi> That's what I need.
<didi> I think.
<stassats> minion: trivial-garbage?  [06:02]
<minion> trivial-garbage: trivial-garbage provides a portable API to finalizers,
	 weak hash-tables and weak pointers on all major CL
	 implementations. http://www.cliki.net/trivial-garbage
<didi> stassats: Thank you, I'll read it.
<stassats> qt is easy in that regard, because some objects take ownership of
	   other objects and are responsible for their deallocation  [06:03]
<stassats> so, you're only concerned with the deallocation of the top-most
	   object  [06:04]
<didi> stassats: That's the same with GtkWindow, for example.  [06:05]
<didi> That's not a bad idea, actually.
<stassats> right, manually deallocating everything will be a nightmare  [06:06]
<didi> Good idea.
<didi> I think I can force objects to be tied to container ones, like Racket
       does it.  [06:07]
<stassats> there are some problems with keeping both sides in sync  [06:08]
<stassats> in commonqt, for example, you can subclass a qt class and add your
	   slots and so you get two objects, one in lisp one in c++, and you
	   need to make sure that both link to each other  [06:09]
<didi> stassats: I'm doing the same approach CFFI's manual use to `easy-handle':
       A CLOS class with a `pointer' slot.  [06:10]
<stassats> your playing around seems to bee too involved! careful, don't create
	   another gtk binding by mistake  [06:11]
<didi> stassats: I will not, I assure you.  [06:12]
<didi> And even if that was really my intent, I would build a
       GObject-Introspection binding.  [06:13]
<stassats> build a new GUI library for wayland, be ahead of the curve  [06:14]
<didi> Nah, I'm good.
<bjorkintosh> curve?  [06:17]
<bjorkintosh> wayland temporarily sucks.
<p_l> permanently as well
<p_l> fit for embedded, not desktop, IMHO
<stassats> uh oh, what have i done
<pjb> -
<p_l> stassats: you woke the wayland hater ;)
<p_l> don't worry, I'm busy with ctf, no more commenting on GUI ;P  [06:18]
<bjorkintosh> i am hoping for an excellent X replacement sometime, but from what
	      i have seen ... we just have to wait.
<ghast> is wayland a dissapointment?  [06:33]
<stassats> ghast: it is off-topic for sure
<ghast> true.  [06:34]
<bjorkintosh> ghast. so far, yes. but i am keeping my fingers crossed
	      nevertheless.  [06:37]
<bjorkintosh> it is a work in progress.
<ghast> i see. too bad :(  [06:39]
<[6502]> sleeptime for me... g'night guys  [06:44]
*** homie (~user@xdsl-78-35-128-150.netcologne.de) is now known as Guest51780
									  [07:24]
<didi> Hum, CLISP SIGSEGV after evoking (qt-conv:main) from (ql:quickload
       "qt-tutorial").  [08:28]
<didi> And (qt-tutorial-14:main) throws some errors. That's strange.  [08:29]
*** arunganesan (~arun@lessentropy.net) is now known as BluePokemon  [08:31]
<didi> But that does not occur with SBCL.
<pjb> Are you using a thread-enabled clisp?  I think qt uses threads.  [08:35]
<didi> Uh, I don't even know that existed.
<didi> I'm using stock Debian's CLISP.  [08:36]
<didi> pjb: Is there a way to know?  [08:37]
<madnificent> didi: i think it should be in *features*
<didi> madnificent: Thanks.
<didi> No mentioning of :THREADS or anything like that.  [08:38]
<didi> :^(
<pjb> So you need to recompile with with threads.  [08:40]
<pjb> ^clisp
<didi> That's a bummer.  [08:41]
<madnificent> (and potentially not use clisp)  [08:45]
<didi> CLISP threads are scary: `--with-threads=FLAVOR   support multiple
       threads in one CLISP image via OS threads [highly experimental - use at
       your own risk]'  [08:48]
<pjb> Yes, free software is scary like that.  [08:50]
<surrounder> lol  [08:52]
* madnificent doubts 'free' is a distinguishing factor for that  [08:56]
<bjorkintosh> software is scary like that.
<lucca> free is just more honest about it  [08:57]
<pjb> $commercial software is usually accompanied by $marketing, which means
      something like: buy clisp, and you'll get hot chicks on a caribean beach!
<pjb> No mention of STD or threads.  [08:58]
<madnificent> pjb: which makes me wonder where beach hangs out these days
									  [08:59]
<pjb> No idea.  I imagine he made a faux-pas in Vietnam and he's languishing in
      some Vietnamese measles.  [09:00]
<_travis_> xach: i don't know if this is intended or not, but i used
	   quickproject to make a project, and it errored because the depends-on
	   wasn't a list. but it still created the readme.txt so when i fixed
	   the error and reran it it still wouldn't work. obviously it was an
	   easy fix to delete the readme, but not sure if thats an intended
	   effect.  [09:03]
<pjb> Or he probably just retired, since his web page from Bordeaux disappeared.
<Xach> _travis_: probably should sanity check before doing stuff to the
       filesystem.
<_travis_> i'm confused :(  [09:04]
<Xach> _travis_: quickproject could be improved so it doesn't have the issue you
       ran into  [09:05]
<_travis_> oh gotcha
<_travis_> i misunderstood what you said. either way, it's a very helpful tool
	   :)  [09:06]
<didi> (1+ _travis_)
<didi> Oh well, I recompiled it but it still doesn't show up at *features* and
       CLISP still SIGSEGV with CommonQt's tutorial from Quicklisp. Nah, I don't
       want to play this game right now.  [09:25]
*** PuercoPop (~PuercoPop@190.41.173.174) is now known as Guest62257  [09:31]
<madnificent> didi: if it's the same for you, perhaps sbcl or ccl can make life
	      easier on you on the short run  [09:37]
<didi> madnificent: Actually, it is. I was using SBCL before. Just trying things
       out. I'm cheering for the inclusion of CCL in Debian. I guess I will get
       back to SBCL.  [09:42]
<madnificent> for what it's worth: CLISP has its place, but for most things SBCL
	      makes things easy.  CCL is quite good too, but i'm less accustomed
	      to it.  [09:51]
<Bacteria> madnificent: I ended up completing the program. I've had it produce
	   output for one of the human chromosomes, we're now correlating it
	   with our expiermental mass spec data.  [09:52]
<Bacteria> I'll let you know soon enough if we find anything new.
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [10:11]
*** cfy (~cfy@unaffiliated/chenfengyuan) is now known as cherrot_  [13:10]
*** cherrot_ (~cfy@unaffiliated/chenfengyuan) is now known as cfy  [13:11]
*** cfy (~cfy@unaffiliated/chenfengyuan) is now known as cherrot_  [13:15]
*** cherrot_ (~cfy@unaffiliated/chenfengyuan) is now known as cfy  [13:16]
*** cfy (~cfy@unaffiliated/chenfengyuan) is now known as cfy_
*** Quadresce (~quad@unaffiliated/quadrescence) is now known as Quadrescence
									  [13:24]
*** stardiviner (~stardivin@122.236.243.185) is now known as NagatoPain  [15:19]
*** NagatoPain (~stardivin@122.236.243.185) is now known as stardiviner  [15:20]
<bjorkintosh> why was xlisp so popular?  [15:59]
<mal__> it was portable and came with a lot of mathematical stuff builtin,
	before R etc were available  [16:01]
<bjorkintosh> well, that was xlisp-stat.
<bjorkintosh> what i don't understand, was why it wasn't cl-stat
<bjorkintosh> autolisp is also based on xlisp.  [16:02]
<mal__> if clisp had been out earlier, I might have been cl-stat  [16:06]
<mal__> there weren't many free, portable, fully featureds lisps around at that
	time
<bjorkintosh> hmm.  [16:07]
<edgar-rft> I think the main reason was that XLISP was tho only lisp at that
	    time that was capable to run on small computers, i.e. MS-DOS
	    machines with 640kB RAM  [16:08]
<bjorkintosh> makes sense.  [16:10]
*** cfy_ (~cfy@unaffiliated/chenfengyuan) is now known as cfy  [16:22]
*** Guest62257 (~PuercoPop@190.41.173.174) is now known as PuercoPop  [16:28]
<ivan-kanis> should I write lisp or Lisp ?  [16:30]
<bjorkintosh> lithp  [16:32]
<ivan-kanis> heh
<bjorkintosh> matters not, really.
<ivan-kanis> I am not sure about the capital in front
<loke_erc> Lisp is a name, and as such it should be capitalised
<bjorkintosh> who are you writing it for, ivan-kanis?
<bjorkintosh> vms or unix?  [16:33]
<pavelpenev> as long as its not LISP, its ok by me.
<ivan-kanis> just doing a blog on it
<bjorkintosh> aha! On Lisp?
<bjorkintosh> what do you have to say?
<ivan-kanis> why it's relevant to me
<bjorkintosh> why is lisp relevant to you?  [16:34]
<pavelpenev> hope it does not contain misinformation, we would hate to destroy
	     it rhetorically.
<ivan-kanis> bjorkintosh: well look at my blog
<moore33> So, knowing all the issues about macroexpansion, etc., is there any
	  capability in slime to add breakpoints without modifying the source?
									  [16:35]
<bjorkintosh> ivan-kanis, where is said blog?
<ivan-kanis> bjorkintosh: you've heard of Google?
<pavelpenev> ivan-kanis: the burden to provide a link is on you.  [16:36]
<bjorkintosh> given that its yours, i thought you would have proudly spammed it.
<ivan-kanis> http://ivan.kanis.fr/blog.html
<ivan-kanis> bjorkintosh: I am not Xah Lee
<bjorkintosh> i see a lot about emacs. i suppose the one you spoke of if a work
	      in progress.  [16:38]
<ivan-kanis> yes
<ivan-kanis> writig it right now
<pavelpenev> is it about elisp or common lisp?
<ivan-kanis> well I like to do both
<ivan-kanis> it's not easy
*** [SLB]` (~slabua@unaffiliated/slabua) is now known as [SLB]  [17:19]
<H4ns> "can you program in java?" "sure, but you pay the travel expenses"
									  [17:25]
<cfy> haha  [17:33]
<ivan-kanis> http://ivan.kanis.fr/lisp.txt  [17:44]
<ivan-kanis> feedback welcome
<dim> "Of course it's not as fast as C but it's decent nonetheless." -> audience
      stops reading here, or considering you have something interesting for
      them, IMO, plus, it seems like it's not true what you're saying  [17:47]
<pavelpenev> ivan-kanis: very... spartan.
<dim> and I don't think FFI is about getting C speed, it's all about reusing C
      code and libs so that you don't have to rewrite them
<anvandare> i hear they're working on something called html that can make
	    personal pages so much prettier :>  [17:48]
<pavelpenev> Also ecl compiles to C, so its C speed :)
<anvandare> aside from that, it's a nice summary of a few of the strength points
	    of lisp
<Cymew> If you talk to someone who is not a lisp head, don't even mention the
	speed word. That's all they will remember. At least that's my
	experience.  [17:49]
<dim> then just tell them that in some cases lisp is faster than C
<loke_erc> anvandare: I recently attempted to explain the benefits of Lisp, too:
									  [17:50]
<loke_erc> https://plus.google.com/115209488640908180409/posts/h6B8xU5yT4v
<dim> look the perfs table at http://norvig.com/python-lisp.html ivan-kanis
<anvandare> lisp is much much faster than any language... if you incalculate
	    development time!
<ivan-kanis> pavelpenev: my strength is not writing...
<pavelpenev> actually a better approach is to say that while C makes it easy to
	     write wrong and fast code, and takes an expert to make it correct,
	     lisp makes it easy to write correct code, and takes a bit of
	     experience to make it fast.  [17:51]
<dim> lisp exception handling appears to be 100 times faster than C++ one in
      that document
<ivan-kanis> Cymew: well a strong misconception is that it's slow so I think
	     it's important to mention
<Cymew> python is slow and ruby is *really* slow but fanboys don't mention
	that. They speak about the strengths. I think lispers should do the
	same.  [17:52]
<Cymew> Answer the speed issue when someone explicitly asks about it
<Cymew> People always remember the bad stuff, so talk about the good bits.
<ivan-kanis> Cymew: hmm, ok, I'll cut  [17:53]
<Cymew> At least that's my opinion
<anvandare> "are you building an OS or handling multiple terabytes of data? if
	    not then speed shouldn't be your main issue"
<pavelpenev> ivan-kanis: check out my "lisp misconceptions" blog post:
	     http://pavelpenev.posterous.com/learning-lisp-the-bump-free-way
	     from my inexperienced, but insanely enthusiastic period.
* pavelpenev should probably return to blogging, now that most of the empty
  enthusiasm is replaced with bittersweet experience.  [17:54]
<Cymew> Many voices singing the praises of the good parts is why "everyone"
	knows about python. Also, it's quite to get going and hack away. It even
	has a repl, like some other languages we could mention... :)
<Cymew> quite easy, that is.  [17:55]
<ivan-kanis> Cymew: ok it's cut
<Cymew> Sorry if I harp on about this. Pet peeve. Sorry. ;)
<ivan-kanis> you can refresh to see the update
<ivan-kanis> Cymew: I don't feel you're harping, you're helping me make it
	     better  [17:56]
<pavelpenev> Cymew: I actually like the fact that the lisp community is less
	     marketing focused. It's insanely refreshing to those of us who
	     value intellectual honesty.
<pavelpenev> that said, the doom and gloom mentality is worse even worse
<pavelpenev> rm the first worse  [17:57]
<punee> what does it mean for a community to be marketing focused?  [17:58]
<pavelpenev> ivan-kanis: A bit of advice from another bad writer who wants to be
	     better: write, stop, in 30 mins reread it, if it sounds like crap,
	     scrap it and rewrite it. Takes weeks to publish anything and it
	     still sucks, but its better.  [17:59]
<punee> people in any somewhat large community will have wildly diverging
	interests
<Cymew> pavelpenev: I kind of agree, but there's moderation in all things.
									  [18:00]
<pavelpenev> punee: have you read many ruby or python blogs from say 2008, or
	     some recent node.js blogs? Or the clojure blogs, written from the
	     clojurians who came to it from java?  [18:02]
<ivan-kanis> pavelpenev: nah, it will never be good. I just got in the habit of
	     blogging once a week.  [18:03]
<punee> not really
<ivan-kanis> I used to really like Python but then the interest wore off  [18:04]
<ivan-kanis> I think Python3 is a disaster
<ivan-kanis> An then the Unicode handling... yuck...
<pavelpenev> punee: it seemed in 2008 that every second blog post about python
	     was about closures or list comprehentions, or how you don't need to
	     write type declarations as proof that the language was the best
	     thing EVA!
<pavelpenev> I know, because I wrote half of them in bulgarian :)  [18:05]
<punee> these must have been pretty boring posts
<punee> but i still don't understand how that's marketing related
<dim> ivan-kanis: I think you could talk even more about the development
      environement, the dynamics of writing code (with SLIME for example)
<dim> when I'm back to writing C the lack of C-M-x is really really bad  [18:06]
<punee> of course languages that are used more in the workplace are going to
	have more discussions about concrete/product oriented stuff, while
	languages for hobbyists/academics will have more theoretical discussions
<pavelpenev> punee: well, the comunity feels as their duty to promote tha
	     language in every situation posible, and over exadurate its
	     merit. I see this with lisp too, but the ratio of lisp programmers
	     over 30 is sufficient to make it less of an issue.
<ivan-kanis> dim: well, the thing is I don't do CL...
<punee> oh right, so you mean marketing the language itself  [18:07]
<punee> i don't feel like that's very true of python anymore
<ivan-kanis> dim: it shows in my article
<dim> ivan-kanis: so the document should explicitely mention elisp then, I think
<ivan-kanis> dim: well I think highly of CL, I just don't program much
	     anymore...
<pavelpenev> punee: If you misunderstood me to mean that marketing people use
	     those languages, and its my fault, I apologize, and yes, python is
	     somewhat more mature, all the kids moved to JS.
<pavelpenev> I actually regard python to be the most mature of all the "kool
	     kids" languages  [18:08]
<ivan-kanis> dim: re-reading the article I don't think it should be elisp only
									  [18:09]
<dim> mention that's the experience you're building the article on then
<ivan-kanis> dim: my goal is to demonstrate why I like Lisp
<ivan-kanis> dim: ok
<ivan-kanis> dim: like on top as an introduction?
<dim> I think so  [18:10]
<ivan-kanis> dim: "Most of my experience whith Lisp is Emacs Lisp but this
	     article talks
<ivan-kanis> about Common Lisp too."
<punee> so, "with"?  [18:11]
<punee> :)
<dim> or "most of it applies also to CL"?
<ivan-kanis> "I am mostly experienced with Emacs Lisp but this article applies
	     to Common Lisp."  [18:13]
<pavelpenev> ivan-kanis:  i find that just careing about good writing improves
	     it. The attitude of "I'm not good at writing" is like a self
	     fulfiling prophesy. I suggest you scrap the whole thing, rethink it
	     why it is written, what you want to say and write it again. It will
	     certainly be better. Right now it feels like a very rough first
	     draft.  [18:14]
<Cymew> The thrust of the text is good, but pavelpenev's advice is good.  [18:15]
<dim> it's a good draft, tho, ideas are clear
<Cymew> indeed
<moore33> ivan-kanis: There isn't a function called doloop, and if there were,
	  it wouldn't be a function.
<dim> try to find a story to tell in the first Â§ it always work fine
<pavelpenev> yes, it is clear.
<ivan-kanis> moore33: hmm shall I call it a macro then?
* Cymew suddenly remembers that he has forgotten to eat lunch...  [18:16]
<ivan-kanis> moore33: i didn't want to make too confusing, I know it's a macro
<pavelpenev> calling a macro a function is more confusing.
<ivan-kanis> dim: ah the catch line, hey?
<moore33> ivan-kanis: You could say "a construct," but in any event figure out
	  which looping construct you mean: do, dotimes, loop...
<pavelpenev> operator would be a better generic term than construct.  [18:17]
<dim> ivan-kanis: you almost have it, with the (hello) example, it's just not
      written as a catch story
<ivan-kanis> pavelpenev, Cymew : ok I'll take the advice about writing and not
	     publish it straight away
<dim> read any JoÃ«l on software article to see some articulated example you can
      get inspiration from  [18:18]
<pavelpenev> just don't overdo it, the reason my blog hasn't been updated since
	     last year is because I start writing, rewrite a post 3-4 times, and
	     get bored with the subject by the end of the week and never
	     publish.  [18:19]
<ivan-kanis> moore33: ok, I rewrote it, refresh
<ivan-kanis> dim: JoÃ«l whoÂ ?
<pavelpenev> joel spolsky, google :)
<pavelpenev> Paul Graham has a few things about writing as well.  [18:20]
<ivan-kanis> ah yes I remember him now
<moore33> ivan-kanis: Ã‡a s'Ã©crit "constructs".  [18:21]
<ivan-kanis> moore33: merciÂ ;)
<moore33> ivan-kanis: My wife is a prof d'anglais :)
<ivan-kanis> dim: great idea, let me think about it
* pavelpenev finds writing extremely rewarding, even If he rarely publishes
  anything.  [18:22]
<pavelpenev> and sucks at it :)
<ivan-kanis> I find writing code rewarding, never been much into prose  [18:23]
* anvandare does that too
<anvandare> pages and pages of nonsensical babbling (ok, maybe a bit better than
	    that, but deemed such afterwards) discarded, time and again
<pavelpenev> thats what *scratch* was made for :)
<Doxin> I've just read http://www.defmacro.org/ramblings/lisp.html , but I fail
	to see what makes lisp unique. or at least different enough to warrant
	all those parentheses?  [18:24]
<anvandare> the parentheses are to lisp what whitespace is to python :P
<Doxin> anvandare: except that whitespace makes it _more_ readable. I'm just
	interested in why lisp is "better"
<axion> just read the first chapter of PCL, and preferably more  [18:25]
<pavelpenev> Doxin:
	     http://s3.amazonaws.com/files.posterous.com/pavelpenev/qygrBgrsqzmwDklbGcpnmnkEHuIEuEGuGeiFtJzprwFJfcdkjlpnpllxCplh/media_httpimg264image_rAqCe.png?AWSAccessKeyId=AKIAJFZAE65UYRT34AOQ&Expires=1345804190&Signature=OF1f74BnQ8WApoT9cpg2RYWU7Ic%3D
<Doxin> pavelpenev: well, at first. yes. but I also understand the why behind
	them somewhat.
<anvandare> I don't think there's a universal standard which makes language A
	    better than language B...
<pavelpenev> Doxin: Lisp isn't better, better is never divorced from the
	     programmers using it.  [18:26]
<Doxin> ...
<moore33> Doxin: I think Steve Yegge has a good article on why the parens are
	  better. Let me look...
<Doxin> right
<anvandare> "it just feels better" probably doesn't sound as convincing an
	    argument. :P
<Doxin> let me put it this way, why did you guys learn lisp? at all? from what
	i've seen it's not all that much special
<Doxin> anvandare: i'd like to know why it feels better to you :P
<axion> because i read the first chapter of PCL. thats why for me
<pavelpenev> Doxin: I learned Lisp because Paul Graham and Erik Raymond told me
	     to.  [18:27]
<Doxin> right
<pavelpenev> but thats not why i stick with it.
<Doxin> why did you stick then?
<pavelpenev> lisp fits the way I think about software better than anything else
	     I've used including python, C, scheme and clojure
<Doxin> hm  [18:28]
<moore33> Hmm, I think I'm confusing it with something else.
<Doxin> pavelpenev: could that possibly be because lisp changed how you think?
<pavelpenev> Doxin: Certainly.  [18:29]
<pavelpenev> We sort of grow towards each other.
<moore33> Doxin: Whether or not you like the parens (and I do), they enforce a
	  regular syntax that makes the parsing of Lisp trivial. From that comes
	  useful macros.
<_travis_> macros still throw me for a loop :\  [18:30]
<anvandare> To me, Lisp is closer to the algorithm, while C is closer to the
	    machine. And I admit I have a very machine-like approach to
	    programming. Perhaps this is due to having learnt C first.
<maxm> linux admin lesson of the day: don't do "ip rule flush". Had to
       reconstruct default routing table by hand
<anvandare> no backups?  [18:31]
<maxm> no, its transient, but I did not want to reboot or kill apps
<_travis_> maxm,  i can appreciate that  [18:32]
<maxm> just surprised that "rcnetwork restart" does not fix it
<maxm> anyway sorry for offtopic
<Doxin> moore33: hmm  [18:34]
<Doxin> moore33: I find lisp to be over-generalised really
<Doxin> moore33: it's like the difference between python and lua, but 10 times
	worse.
<moore33> Doxin: I'm having  trouble parsing  "overgeneralized" without an
	  example...
<Doxin> moore33: eh, it's not something concrete really  [18:35]
<maxm> that over-generalization pays off when you flying by the seat of your
       pants coding wise
<Doxin> moore33: it has less special cases, which is a bad thing if it happens
	too much
<pavelpenev> Doxin: special cases are good idea in your world?  [18:36]
<moore33> Doxin: That is a unique viewpoint :)
<Doxin> maxm: I don't feel like it adds anything I don't have in python
<Doxin> pavelpenev: not always
<Doxin> just when they make life easier
<Doxin> it's like..
<Doxin> eh
<axion> write a python parser
<Doxin> heh
<Doxin> no.
<Doxin> no need
<pavelpenev> what if you want to parse python?  [18:37]
<axion> i rest my point
<Doxin> a list like this: (("a",3),("b",4)) is a less specialised form of a dict
	like this {"a":3,"b":4}, and yet the second one is easier to use.
<moore33> Doxin: I can think of examples: no operator precedence, for
	  example. But I like Hewlett-Packard calculators too.
<Doxin> axion: there's no need to do that really
<maxm> Python model of everything is a dict/hash is attractive, but has large
       performance penalties
<Doxin> axion: python has some very neat builtin modules to do that :P
<Doxin> maxm: not saying that
<Doxin> maxm: that's not true in python either
<Doxin> maxm: but at least you can choose between a dict and a list  [18:38]
<Doxin> which afaic lisp doesn't have.
<pavelpenev> Doxin: lisp has hash tables
<maxm> like eve online developers found out.. 100 objects each with 10
       attributes -> one tick runs in a second.. make it 1000 objects, and it
       dies horribly
<Doxin> pavelpenev: how?
<maxm> with no way to fix it, coz its dicts on top of dicts on top of dicts
       everywhere
<moore33> Doxin: That list *is* a special case in Common Lisp: there is a family
	  of functions to do lookups, reverse lookups, etc.
<Doxin> maxm: they've got a horrible implementation then
<loke_erc> doxin:
	   http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_has.htm
<pavelpenev> Doxin: (make-hash-table)
<Doxin> moore33: right, but still a list  [18:39]
<moore33> Doxin: So?
<pavelpenev> Doxin: you obviously don't know lisp, so you are probably trolling.
<Doxin> no no
<Doxin> I'm seriously trying to find out stuff here
<axion> Doxin: have you read any of PCL yet?
<Doxin> loke: I really dislike the syntax there.  [18:40]
<Doxin> axion: not yet, no.
<moore33> Doxin: I don't think that all data structures should be lists all the
	  time, by any means, but they are perfectly appropriate for a small
	  dictionary.
<axion> please see Peter's introduction. I was VERY skeptical about lisp, being
	talked about by my friends, until I finally read it.
<Doxin> hmm
<Doxin> axion: reading it now  [18:41]
<loke_erc> Doxin: you can see that as the foundation
<Doxin> loke_erc: but this is where a special case can be nice. dict[key] is
	nice syntax to me. I like it better than (dict-lookup "key" dict)
									  [18:42]
<loke_erc> Doxin: hashtables are only faster once you go above a certain number
	   of elements (how many that is, depends). most list-based lookup lists
	   are very small in lisp, just a handful of elements, which are if not
	   after at least as fast as a hash table
<pavelpenev> Doxin: even if you're not doing it intentionally, you're trolling.
<Doxin> loke_erc: I know, I just dislike the syntax there
<loke_erc> Doxin: Well, it's a good thing that Lisp allows you to create a
	   syntax for that then, if you want to :-)
<Doxin> pavelpenev: then explain how not to?
<H4ns> Doxin: repeating your sentiment does not make it any better
<Doxin> loke_erc: hmm  [18:43]
<Doxin> H4ns: am I implying it does?
<loke_erc> Doxin: building a reader macro that allows you to type, say,
	   @foo["bar"] is trivial
<Doxin> hm
<moore33> loke_erc: Also completely horrible :)
<Doxin> loke_erc: how much of a bad practice is it to rewrite python in lisp
	though?
<H4ns> Doxin: if you dislike the syntax so much that you feel like stating it
       again and again, you should find something else that pleases you more.
<loke_erc> moore33: I agree, which is my most lisp programmers don't do that :-)
<loke_erc> Doxin: you're the one saying you prefer that syntax. We don't.
									  [18:44]
<Doxin> H4ns: I have, I'm just trying to figure out why I hear so many people go
	orgasmic about lisp.
<pavelpenev> Doxin: you know nothing of lisp, yet have strong opinions about
	     it. Learn it, and we will help you with the process as best we can,
	     just tone the opinions down until you acquire a clue.
<moore33> Even if the language is infinitely configurable, it is very
	  unproductive to go into it ignoring its existing  culture.
<Doxin> pavelpenev: hm.
<pavelpenev> Doxin: I dislike python, but I know it fairly well, even though I'm
	     a bit rusty. And I very rarely go to python forums or channels to
	     share my dislike, in fact, I never do that.  [18:46]
<loke_erc> pavelpenev: Perhaps you should
<loke_erc> :-)  [18:47]
* pavelpenev goes off to troll #python... not :)  [18:48]
<_travis_> i can't help but feel like this conversation is an every day
	   occurence
<moore33> Doxin: If you wanted, you could define a generic function [] that does
	  your key lookup on a hashtable, alist, sequence... you could even
	  define the generic setter too. But you would write it ([] table key),
	  because that is just what we do in Lisp.  [18:49]
<moore33> I don't try to write C++ in prefix notation.  [18:50]
<moore33> Even I am a bit put off by the hairyness of this form: (setf
	  (gadget-value pane :invoke-callback t) item-value)  [18:52]
<moore33> I.e., setf functions that take extra arguments.
<pkhuong> If I write a different language, it shall be named Nair.
*** Tordek (tordek@supporter.blinkenshell.org) is now known as Yes  [18:55]
*** Yes (tordek@supporter.blinkenshell.org) is now known as Tordek
<Doxin> I bet I can implement lisp in python as a dsl  [19:08]
<pavelpenev> Doxin: not that difficult, parsing lisp is trivial compared to
	     parsing python.  [19:11]
<Doxin> that's true  [19:12]
<moore33> What is "lisp?"
<Xach> baby don't hurt me, don't hurt me, no more
<_travis_> maybe someone can explain this to me. in PCL, the id3v2 parser
	   pratical, he constantly checks the caracter code in this way: (<=0
	   code #xffff)   now, #xffff is a constant right? what purpose does it
	   server to continually check that it is indeed greater than 0?
<_travis_> i'm sorry, (<= 0 code #xffff)  [19:13]
<Xach> _travis_: it's not checking that #xffff is greater than 0, it's checking
       that the value of CODE is less than that value and greater than 0
<pavelpenev> <= checks that the arguments are a progression.
<_travis_> oh
<_travis_> good lord
<_travis_> i need more coffee obvoiusly  [19:14]
<anvandare> lol
<Xach> or that they are nondecreasing
<_travis_> thank you for the slap.
<anvandare> actually that's a very rare feature
<pavelpenev> Doxin: check out http://common-lisp.net/project/clpython/
<_travis_> when i did some trivial tests at the REPL i completely misunderstood
	   the results
<anvandare> In most languages, you'd have to do if (0 <= code && code <= #xffff)
	    blah
<_travis_> right, makes complete sense now.  [19:15]
<anvandare> or some other structure in which you'd constantly have to restate
	    the control value again and again
<Doxin> pavelpenev: I'm not talking about implementing lisp. I'm talking about
	writing a python program that extends python to _be_ lisp.
<_travis_> so dumb early lesson that i should have learned in comp sci 101,
	   checking the spec > stupid command line style testing.  [19:16]
<pavelpenev> Doxin: you mean ["defun", "hello world", [], ["print", "Hello
	     world"] ]?  [19:18]
<Doxin> pavelpenev: no,  [19:19]
<Doxin> pavelpenev: I mean import lisp and then start writing lisp intermingled
	with python.
<Doxin> shouldn't be too hard
<daimrod> Doxin: thanks to cl-python you can do it the other way. i.e. write
	  python within CL.  [19:38]
<Doxin> daimrod: :I  [19:41]
<Doxin> since when is it a good idea to drop to a debugger on each and every
	error?  [19:43]
<H4ns> Doxin: let me see.  since... the invention of interactive computing in
       the 1960ies?
<pavelpenev> Doxin: the 60's
<Doxin> I can't remember the last time I needed a debugger in python. how about
	not dropping to a debugger and giving usefull output instead?
									  [19:44]
<H4ns> Doxin: have you tried reading the error output that appears before the
       debugger prompt?  [19:45]
<Doxin> yep  [19:46]
<H4ns> Doxin: well, then i'm unsure what you're looking for.  something like
       "segmentation fault, core dumped" and a shell prompt?
<Doxin> hah  [19:47]
<Doxin> no
<H4ns> ... but?
<Doxin> H4ns: python tracebacks are rather nice.
<H4ns> Doxin: you keep talking about python.  this channel is about lisp.
<Doxin> I know
<H4ns> Doxin: did you look at the backtrace yet?
<H4ns> Doxin: what is missing in it that you'd like to see?
<pavelpenev> Doxin: Lisp debbugers are nicer
<Doxin> H4ns: maybe it's just because I haven't learned to read it yet  [19:48]
<Doxin> pavelpenev: how so?
<H4ns> Doxin: ah, we're getting closer.
<H4ns> Doxin: are you using slime or a bare repl?
<pavelpenev> sometimes they give you options to recover from an error
<Doxin> H4ns: bare.  [19:49]
<Doxin> pavelpenev: I have yet to find a scenario where this helps
<Doxin> pavelpenev: ( implementing an error handler like that in python is
	trivial anyways )
<daimrod> you mean you can recover from different point in your stacktrace with
	  new values?  [19:50]
<H4ns> Doxin: you should really use slime, but most repl debuggers can be useful
       as well.  you do need to look in your implementation's documentation for
       usage notes, though.
<pkhuong> Doxin: why are you here? You seem to be hellbent on convincing us that
	  python does things better than CL, but none of us asked you to come.
<H4ns> Doxin: you do not yet know anything but judge that you only need what
       python provides.
<pkhuong> Please, do use python.
<Doxin> pkhuong: just trying to figure out if it's worth learning lisp, not
	trying to convince you at all  [19:51]
<H4ns> Doxin: i'd recommend that you either stick to python or stop thinking
       about it while you're learning lisp.  i know it is hard, but you could
       start by not telling _us_ about python.
<Doxin> right
<pavelpenev> Doxin: You aren't doing that. You are obviously confirming your
	     bias that lisp isn't "special".  [19:52]
<H4ns> Doxin: what does "worth" mean to you?  what would make learning lisp
       worthwhile for you?
<pkhuong> Doxin: lisp is a worst python than python.
<pavelpenev> you show great signs of having already made up your mind. IOW You
	     are wasting your time. I said, we will help you if you acquire a
	     clue and stop trolling. Just don't try to judge lisp before you
	     learn enough of it to not sound like a moron.  [19:54]
<Doxin> pavelpenev: I'm trying to find out if it is, and if its worth learning.
									  [19:55]
<Doxin> H4ns: it's worth learning if it's fundamentally different from any other
	programming language I know
<mskou72> Anyway, Python is too easy :-)
<H4ns> Doxin: it is not.   it just has features that no other language you know
       has.
<pkhuong> minion: thwap fpr me
<minion> please stop playing with me... i am not a toy
<Doxin> H4ns: such as?  [19:57]
<H4ns> Doxin: you discovered something already:  when there is an error, you
       land in a debugger.
<Doxin> H4ns: not unique to lisp.
<H4ns> Doxin: also macros, clos, mop, generic functions with multiple dispatch,
       the reader.
<daimrod> Doxin: http://www.paulgraham.com/diff.html
<pavelpenev> Doxin: lisp is worth learning. Take my word for it. No, don't take
	     my word for it. Learn it, and _THEN_ make up your mind about its
	     value.  [19:58]
<H4ns> daimrod: what an impressive list!  garbage collection, wow!
<daimrod> H4ns: did you read the last paragraph?
<pavelpenev> Doxin: http://random-state.net/features-of-common-lisp.html
	     features of Common Lisp
<Doxin> daimrod: none of that is new to me.  [19:59]
<H4ns> daimrod: a list that does not contain anything that makes lisp unique
       today is not helpful in this discussion.
<pavelpenev> It is extremely wrong to judge a language before you know it.
<pavelpenev> a list of features does not make a good rational for learning one.
									  [20:00]
<H4ns> pavelpenev: the whole conversation is pretty pointless, when it comes to
       that.
<theos> but wasting time on a stupid language is also bad  [20:01]
<theos> like learning perl for example
<H4ns> theos: perl is not stupid.  let's please confine our discussion to common
       lisp.  [20:02]
<theos> H4ns all i was saying is that lisp is epic and you wont repent learning
	it :)  [20:03]
<pavelpenev> theos: I repent, It ruined all other languages for me.
<H4ns> minion: chant
<minion> MORE COFFEE
<theos> MOAR
<Odin-> theos: So you didn't say that "like learning perl" line? :)
<theos> and i kinda lagged for liek 1 min or so. that would have made things
	outta context a bit  [20:04]
<theos> earning a new language is a tough decision. its good that lisp has good
	points in favor of it  [20:05]
<theos> learning*
<H4ns> learning a new language is not a tough decision.  you take a book, read
       through it, then decide whether you want to learn the language.  [20:08]
* dim never learnt a language with a book  [20:09]
<pavelpenev> I learned enough VB.net to pass an exam and wrote a project in an
	     afternoon. And I don't even use windows.
<H4ns> dim: neither did i.  [20:10]
<H4ns> dim: a book can help making the decision to learn a language.  the actual
       learning process requires writing actual programs in the language.
<moore33> dim: There was a time before the Internet :)
<dim> moore33: I had manpages then  [20:11]
<pavelpenev> the problem is judgment rigidity. When I make a value judgment
	     about a technology too early, It takes me a lot of effort to remove
	     it if I find evidence to the contrary. That is why i try to judge
	     less.
<dim> H4ns: ack
<moore33> dim:That would be a hard way to learn a language.
<theos> dim manpages are books no?  [20:12]
<dim> not designed to be sold, makes a huge difference  [20:13]
<theos> you dont have to buy a book :P
<H4ns> i find it amazing that many books on languages are written by people who
       do not actually know the language very well.  [20:14]
<theos> i get what you are saying. but some books are worth reading
<H4ns> this does not mean that those books are not good.  it is just kind of
       reflective of the fact that reading books and learning languages are two
       different things.
<theos> and a lot of books are copied from other books :D
<dim> the only way I've found that works to learn a language is find a small
      enough project and implement it in said language, then a bigger one etc
									  [20:15]
<moore33> Has anyone customized the git chunk headers to give useful output for
	  Lisp? Is that  even possible?
<ivan-kanis> dim: checkout my "story" at the beginning
	     http://ivan.kanis.fr/lisp.txt  [20:18]
<ivan-kanis> dim: I learned a lot via books  [20:19]
<H4ns> ivan-kanis: you repeat two sentences with "What is wonderful about Common
       Lisp is that it doesn't impose.."  [20:20]
<H4ns> ivan-kanis: and while i understand what you say, i would not stress that
       point too much.  it could appear as if lisp code is mostly messy because
       no common style is followed.  i'd stress the multi-paradigm aspect more.
									  [20:21]
<ivan-kanis> H4ns: nice catch! fixed!
<ivan-kanis> H4ns: the second point is tricky  [20:22]
<dim> you could link and inspire from the recent article I read about "idioms"
      in programming languages, where CL has much less (if any) idioms  [20:23]
<dim> trying to find that again
<dim> http://learncodethehardway.org/blog/AUG_19_2012.html  [20:24]
<ivan-kanis> H4ns: instead of saying "it doesn't impose a programming style" I
	     could say "it's multi-paragdim"  [20:25]
<H4ns> ivan-kanis: yes.  be positive.
* pavelpenev passes out from 30 hours of abusing caffeine, studying math, barely
  passing intense differential geometry exam, drinking beer and battling trolls
  on #lisp  [20:26]
<ivan-kanis> H4ns: done, thanks!
<Zhivago> Isn't that article about how they're not idioms? :)  [20:27]
<ivan-kanis> dim: nice article  [20:33]
<ivan-kanis> where that's story where people repaired something like a Mars rove
	     with a REPL? I'd like to quote it.  [20:39]
<ivan-kanis> s/rove/rover
<ivan-kanis> nm, i found it with google  [20:41]
<dim> ivan-kanis: I guess I would show a loop example to explain what are
      macros, like fibonnaci with loop
<dim> (defun fib (n) "Return the n'th number from the Fibonacci series" (loop
      repeat n for x = 0 then y and y = 1 then (+ x y) finally (return y)))
<moore33> ivan-kanis: The mars rover story is actually about VxWorks. The person
	  formerly known as Erann Gat talks about fixing a Lisp system in deep
	  space using the REPL.  [20:42]
<ivan-kanis> moore33: thank you, that's what I was thinking of  [20:43]
<Xach> gat's lisp stories all have the moral of "and i was never allowed to do
       lisp again"  [20:45]
<Xach> sub-moral: "see how awful lisp is?"
<ivan-kanis> hmm I am trying to find the quote where he says it was useful to
	     have a REPL to fix his system in deep space  [20:46]
<adeht> ivan-kanis: http://www.flownet.com/gat/jpl-lisp.html  [20:47]
<adeht> "(Debugging a program running on a $100M piece of hardware that is 100
	million miles away is an interesting experience. Having a
	read-eval-print loop running on the spacecraft proved invaluable in
	finding and fixing the problem. The story of the Remote Agent bug is an
	interesting one in and of itself.)"
<ivan-kanis> adeht: thank you, I'll add the quote to my article  [20:49]
<ivan-kanis> I am quite happy with my article, I think I'll publish it tonight
									  [21:12]
<adeht> what happened to McConnell's rule, only publish it after two weeks in a
	drawer, untouched  [21:14]
<Cymew> ivan-kanis: Many people have told you you'd better let it sit. I still
	think it's a good idea.  [21:22]
<Cymew> You *will* find faults with it tomorrow...
<ivan-kanis> hehe
<ivan-kanis> well I'll wait tomorrow
<ivan-kanis> you guys are right, I'll wait _gasp_ two weeks  [21:24]
<Xach> by then lisp will be obsolete  [21:25]
<ivan-kanis> :D
<Zhivago> Just drink a bottle of whiskey and see what happens.  [21:30]
<wbooze> is there something like that in lisps format printf("%d is %sa leap
	 year.\n", year, is_leap_year(year) ? " " : "not ");
<wbooze> i mean that %sa thing  [21:31]
<anvandare_> nearly a quarter century of irc and still random splits and
	     disconnects
<jdz> clhs ~[
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/22_cgb.htm
<stassats> wbooze: strange question  [21:32]
<jdz> clhs ~*
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/22_cga.htm
<ivan-kanis> Zhivago: a whole bottle? I'll think that'll put me in a coma.
<Zhivago> wbooze: Yes, but I recommend not using it.
<Zhivago> ivan-kanis: Ah. Not a writer, then. :)  [21:33]
<stassats> the direct translation is trivial: (format t "~a is ~a a leap year"
	   year (if (leapp year) "" not"))?
<ivan-kanis> Zhivago: I hate writing
<Zhivago> ivan-kanis: Generally speaking, perfection is not that valuable, and
	  minor errors give people opportunities to feel intelligent and
	  contributory.
<wbooze> ah ok
<Zhivago> ivan-kanis: So, I'd publish it with open feedback and iterate when you
	  get bored.  [21:34]
<Zhivago> wbooze: Things like that sound like good ideas until one day you
	  decide that internationalization might, after all, be a good idea.
<ivan-kanis> Zhivago: I'll follow people's advice and wait a bit
<ivan-kanis> I am trying to explain why I like Lisp  [21:35]
<Zhivago> ivan: You might start with something more simple, like why you like
	  chocolate or puppy dogs.
<stassats> ivan-kanis: but you're an irrational human being, you can't explain
	   that!  [21:36]
<ivan-kanis> Well I feel my fellow developers are misguided, I am trying to make
	     a case that Lisp is a good idea...  [21:37]
<ivan-kanis> So I guess I am being an altruist
<Zhivago> ivan: Unfortunately, that is a meaningless statement without a metric
	  for goodness.
<moore33> Zhivago:Looks/pixie.lisp:; This file is in transition, please don't
	  fix it :] I presume that, 10 years later, one could go ahead and fix
	  it? :)  [21:38]
<ivan-kanis> Zhivago: there is no definition of "quality" either
<Zhivago> moore33: Oh, I think deletion is probably the answer.  [21:39]
<ivan-kanis> Zhivago: we just know it is
<stassats> ivan-kanis: MTBF?
<Zhivago> ivan: There are lots of definitions of quality.
<anvandare_> evangelisp: someone spreading the good news of the salvation of
	     lisp  [21:40]
<Zhivago> ivan: The trick is picking a useful one for your domain.
<stassats> anvandare_: as long as there will be autodafes, i'm in
<Zhivago> ivan: So, instead of trying to say "Lisp is a good idea", why not try
	  "I've found Lisp useful for the following things ..."?  [21:41]
*** anvandare_ (~anvandare@ip-83-134-160-254.dsl.scarlet.be) is now known as
    anvandare
<madnificent> ivan-kanis: i've been reading the art of motorcycly maintenance
	      and it has a very interesting rhetoric about quality.  [21:47]
<moore33> From looking at that earlier link, it seems that "Learning Ruby the
	  Hard Way" is aptly titled. What a heap of shit.  [21:49]
*** superflit_ (~superflit@75-171-194-92.hlrn.qwest.net) is now known as
    superflit  [21:51]
<H4ns> moore33: ruby is off topic here.  [21:52]
<moore33> "All the original prose of "Learn Python The Hard Way" but with new
	  source code that teaches you Ruby instead of Python." As if. What you
	  you say if "Ruby" was replaced by "Common Lisp?"
<moore33> H4ns: Writing  about languages is not, apparently.
*** PuercoPop (~PuercoPop@190.41.173.174) is now known as Guest63098  [21:56]
<Zhivago> I'm not too impressed with his attempt on C, either.  [22:03]
<wbooze> what is leap_second good for when it's not used in any implementation ?
									  [22:14]
<wbooze> lol
<wbooze> hey Zhivago hi  [22:15]
<wbooze> and when do you add that ? every 18600 years ?  [22:16]
<wbooze> ah, IERS decides  [22:20]
<madnificent> wbooze: leap seconds get added regularly to fix the correspondence
	      between position of the earth vs the sun and the time we use.  the
	      name leap_second doesn't seem like lisp though, so i'm wondering
	      why it is posed here.
<wbooze> regularly, wiki says it's irregular  [22:21]
<madnificent> often, but still, why is this on topic?\  [22:22]
<H4ns> madnificent: it is not.  wbooze is not known for staying on topic.
<wbooze> nvm
<madnificent> harish: ty
<madnificent> hrr
<madnificent> grrr
<madnificent> H4ns: thank you!  harish, sorry  [22:23]
<wbooze> does anyone know how can i add a C-x 8 RET thing to the default
	 command-table of mcclim app, to invoke the use of unicode names or so ?
									  [22:25]
<wbooze> bleh
<oGMo> hrm no gnutls wrapper?  [22:27]
<phadthai> there's http://www.cliki.net/SSL-CMUCL for openssl though, or
	   ironclad  [22:31]
<oGMo> yeah not quite the same sadly  [22:33]
<oGMo> (and cl+ssl which i believe is a port of ssl-cmucl(?))
<phadthai> curl/cl-curl if the goal is for an https client, for servers there
	   also are proxying httpds that can also provide the ssl layer for
	   application servers
<phadthai> maybe
<oGMo> yeah .. need to implement a secure layer over zmq, so need the
       lower-level stuff  [22:34]
<Fade> I wonder if we're going to start seeing people coming in here trying to
       write code in the reader syntax being developed by the 'readable lisp
       s-expression project'.  [22:42]
<oGMo> what's this?  [22:43]
<oGMo> as opposed to prefixing everything with #<?
<Fade> http://readable.sourceforge.net/  [22:44]
<Fade> I have the strongest feeling this project is an ellaborate solution in
       search of a problem.
<H4ns> i have the feeling that i need to put my hand on my forehead and sigh
<Fade> I did ezzackly the same thing.  [22:45]
<Inode> looks a lot harder to read than the usual syntax
<oGMo> looks like m-expressions
<wbooze> leap-smear lol
<oGMo> and more complicated special case BS than sexps .. so what's the benefit
									  [22:46]
<Fade> apparently people that aren't me can read inferred syntax more easily
       than concrete fully parenthesised syntax.
<oGMo> didn't someone already write a reader extension to do infix math if you
       really want that?  [22:47]
<Fade> claims to maintain homoioconicity.
<Fade> doesn't clobber standard s-exp syntax, which is interesting.  [22:48]
<Fade> but the effort required to develop this project obviously indicates that
       some people think syntax is 'the problem' wrt lisp.
<Fade> I don't see how {2 * 3 * 4 * 5} is better than (* 2 3 4 5) though.
									  [22:49]
<wbooze> it's not better!  [22:50]
<wbooze> it's just different
<bjorkintosh> it IS better.
<bjorkintosh> the notation was created for a reason.
<Inode> it's more expensive to parse infix notation, isn't it?
<bjorkintosh> yes.
<Fade> yep  [22:51]
<oGMo> dunno but clearly what sexps need to make them better is significant
       whitespace
<jdz> Fade: how about (2 + 3 * 4) / 2?
<wbooze> cheap-in-write -> expensive-in-read ?
<bjorkintosh> Fade, ever heard of Forth?
<wbooze> wtg
<df___> jdz: that wouldn't work as a c-expression  [22:52]
<bjorkintosh> do you know why these things are called polish and reverse polish?
<Fade> of course
<bjorkintosh> so you do know why polish notation was created but you insist it
	      is silly?
<Fade> I insisted nothing of the kind.
<jdz> df___: oh, thanks for pointing this irrelevant fact out to me.
<wbooze> i thought introducing asymmetry was the point!  [22:53]
<ivan-kanis> madnificent: I have read it too, it wasn't coming from me ;)
									  [22:54]
<wbooze> less->more  [22:55]
<wbooze> lol
<wbooze> so they introduced leap-seconds in 2012 already, and why didn't i hear
	 of any catastrophe then ?  [22:57]
<wbooze> buh  [22:58]
<stassats> because you don't read news?
<wbooze> was there ?
<bjorkintosh> microtrophes.  [22:59]
<stassats> depends on your definition of catastrophe, but there were problems
<wbooze> hmmm
<phadthai> some superservers had to reboot thousands of Linux VMs which were
	   were busy-looping (a difference in uptime/reliability and electricity
	   bill)  [23:00]
<wbooze> oh  [23:01]
<madnificent> oGMo: i'm certainly not the only one that has once wrote a macro
	      for that use-case.  it's not that hard to write, but in the end
	      the lisp syntax grows on you for math too (except for < and >,
	      they have a graphical meaning which is destroyed.  [23:05]
<Xach> Destroyed?  [23:06]
<stassats> < doesn't lose anything meaning
<stassats> (< x y) is just (x < y)
<stassats> you just move it
<jdz> madnificent: really? i'd pick (< 0 x 42) over and 0 < x && x && 42
<jdz> oh, whatever
<bjorkintosh> what is 'use case'? why not just say 'case'?  [23:07]
<oGMo> madnificent: yeah what jdz said .. i have found that useful quite a few
       times
<oGMo> madnificent: but, yes
<pjb> wbooze: there was a leap second last june.  [23:16]
<pjb> wbooze: the iregularity is due to the iregularity of Earth slowing (due to
      multiple gravitational influence and the randomness of meteorites falling
      on Earth).  [23:17]
<pjb> wbooze: and also the fact that planes tend to fly East rather than East
      and back West.  [23:18]
<wbooze> dude, it's due to tidal forces...and whatnot i read it already  [23:19]
<wbooze> and even things like earthquakes and tsunamis....
<pjb> oGMo: no, not exactly. m-expressions look exactly like that:
      http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/m-expression/
									  [23:20]
<pjb> Perhaps I should put it on quicklispâ€¦
<pjb> (for exactly the same reasons I programmed it in the first placeâ€¦)  [23:21]
<wbooze> so it's unpredictable .....and when the difference get's noteworthy
	 they decide  to incorporate a leap second 6 months in advance or not
<pjb> Yes.
<wbooze> what i didn't understand was why software would have problems with it,
	 and specifically linux systems....  [23:23]
<p_l> wbooze: the problem happens when you get sub-second calculations in time
      in many places.
<H4ns> "because linux systems are particularly well thought out"?
<p_l> Plus, there was an error somewhere in kernel related to it that caused
      MySQL to blow
<wbooze> well then how about using averages ?
<wbooze> instead of sub-second calcs ?
<pjb> And in any case, you should plan you time libraries and time
      using/processing programs to run on onther planets.  One day on Mars is
      24:39:35 not 24:00:00, and one year is 668.599 sols, not 365.25 days.
									  [23:24]
<p_l> wbooze: because, imagine it, there is quite lot of code where 16ms is big
      difference, not to mention 1000ms inserted randomly
<pjb> wbooze: well, without even accounting for the leap seconds, on unix
      systems a second can be more or less of a second, when the system uses NTP
      and is not synchronized.
<pjb> So anyways, your code should be prepared.  There's a web page listing a
      lot of misconception about time..  [23:25]
<pjb> There: http://unix4lyfe.org/time/  have fun.  [23:26]
<Fade> look at all the trouble MSFT has had over the years with their clocks.
<Fade> time is bizarrely difficult to get right.
<pjb> Actually, I remember a much longer list.
<p_l> Google Engineering had a nice post about how they had to add leap second
      into system without blowing it up
<p_l> wbooze: also, a common "constant" in software developement is ~700ms :)
									  [23:27]
<bjorkintosh> how? they run small experiments to make sure it would not blow up!
*** pkhuong_ (~pkhuong@gravelga.xen.prgmr.com) is now known as pkhuong  [23:28]
<pjb> there's of course: http://naggum.no/lugm-time.html
<p_l> bjorkintosh: the post involved how they "leaked" leap second into cluster
      over a time by modding the NTP server software  [23:29]
<p_l> pushing the clock in small increments over several days
<Fade> that was a clever hack.  [23:30]
<bjorkintosh> hah. they scienced a solution :)
<wbooze> heh  [23:32]
<wbooze> and there were no problems with windows based servers ?  [23:33]
<wbooze> worldwide ?
<bjorkintosh> none that i heard of.  [23:34]
<Fade> you'd have to separate those problems from the rest of the problems to
       find out.
<Fade> heh
<bjorkintosh> no problems with bsd based servers either that i heard of.  [23:35]
<pjb> Ah, it was this page I remembered:
      http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
*** Guest63098 (~PuercoPop@190.41.173.174) is now known as PuercoPop  [23:36]
<pjb> wbooze: there was no problem with MS-windows servers because they are
      rebooted every days at midnight, and the leap second is inserted at
      midnight too.
<H4ns> "right"
<pjb> Nobody knows what would happen if a MS-Windows system was left to pass the
      leap second.
<pjb> jdz: <16:51:04><jdz> Fade: how about (2 + 3 * 4) / 2?   so you mean you
      need an arithmetic DSL?  There's one, it's called f2cl.  [23:38]
<bjorkintosh> pjb, it would probably be crash and require a reboot.
<bjorkintosh> since that happens often enough, it would not be noticed, really.
<jdz> pjb: no, i mean that sometimes infix can be more readable.  [23:39]
<pjb> Yes. There are libraies.
<pjb> Notably I would advise to use them if you have top copy-and-paste formulas
      from a math/physics book.
<pjb> s/top/to/
<Forty-3> how do I convert a character to a string?  [23:40]
<jdz> Forty-3: STRING. but why?
<Forty-3> jdz: I'm imnplementing lzw for fun  [23:41]
<Forty-3> *implementing
<jdz> Forty-3: but why do you want to convert a character into a string?  [23:42]
* Xach implemented lzw for real but characters and strings did not come into
  play
<Forty-3> so I can concatenate it
<jdz> Forty-3: use a stream, then.
<Forty-3> why..?  [23:43]
<Forty-3> it's easier to use a string
<jdz> Forty-3: no, it's easier to use a string-output-stream
<Forty-3> ..
<stassats> to do what?
<Forty-3> implement lzw
<pjb> Forty-3: characters are string designators, so often you don't have to
      convert them to strings.  But when you have (string char) is a nice way.
<stassats> that's not very specific
<Forty-3> stassats: yes it is  [23:44]
<stassats> ok then, carry on
<pjb> Forty-3: notice that with concatenate, you can put your character in a
      list or a vector too, not necessarily in a string.  [23:45]
<Forty-3> so?
<pjb> I'd expect (cons #\c nil) to less expensive than (string #\c).
<wbooze> lol  [23:46]
<Forty-3> pjb: and I canconcatenate a list with a string?
<pjb> (concatenate 'string (cons #\c nil) #(#\a) (string #\t)) => "cat"
<pjb> sure, concatenate works on sequences.
<Forty-3> ok
<pjb> (concatenate 'vector (cons #\c nil) #(#\a) (string #\t)) => #(#\c #\a #\t)
									  [23:47]
<pjb> (concatenate 'list (cons #\c nil) #(#\a) (string #\t)) => (#\c #\a #\t)
<H4ns> if you have some time, check out git://github.com/edicl/hunchentoot and
       do some load testing.  http://paste.lisp.org/display/131188  [23:48]
<stassats> H4ns: what kind of load testing?  [23:49]
<H4ns> stassats: things that might max out the server  [23:50]
<H4ns> stassats: the patches fix ungraceful handling over overload conditions
       and fd leakage
<H4ns> OF overload conditions
<stassats> apachebench mysteriously stopped working  [23:52]
<H4ns> because hunchentoot failed_  [23:57]
<H4ns> ?
<stassats> no
<stassats> have no idea why, just doesn't want to connect to localhost  [23:58]
<rooftopjoe> hi. i'm trying to write a curried version of this procedure:
	     http://ideone.com/XNfHV but i'm not sure how to do it
<pjb> (alexandria:curry #'between 2)  [23:59]
<pjb> rooftopjoe: for a scheme answer, try #scheme.

[Sat Aug 25 2012]
<rooftopjoe> heh, ok, thanks  [00:00]
<stassats> connecting to 0.0.0.0 or the network interface address works fine
<stassats> and to 127.0.0.1, but not to localhost  [00:01]
<H4ns> ipv6?
<stassats> well, everything works fine, just apachebench
<H4ns> maybe it does its hostname lookup "better"
<stassats> well, now after terrorizing hunchentoot with requests, it stopped
	   answering  [00:04]
<bjorkintosh> huchentoot is not robust?  [00:05]
<stassats> bjorkintosh: you should write newspaper headlines
<H4ns> stassats: interesting.  any additional information?
<bjorkintosh> hahaha.
<H4ns> bjorkintosh: in single-threaded mode, i find it to be very robust.
									  [00:06]
<H4ns> bjorkintosh: in multi-threaded mode not so much, that's why i'm not using
       it.
<stassats> H4ns: well, before that, it aborted after 121 requests, but now ab
	   just says apr_socket_recv: Connection reset by peer (104)
<stassats> with [2012-08-24 20:07:02 [WARNING]] Can't handle a new request, too
	   many request threads already  [00:07]
<stassats> at the very beginning
<H4ns> stassats: that is the thing that mathieu wanted to fix.
<stassats> although wget still works fine  [00:08]
<H4ns> stassats: thanks - i'll post that to him, maybe he can reproduce and fix
       the issue.  is that with linux against linux on one box?  how many cores?
       sbcl?  [00:09]
<stassats> yes, 4 cores
<H4ns> ok.  will post.  [00:10]
<stassats> 1000 concurrent requests
<stassats> old hunchentoot bails out after ~700 requests, but i can restart
	   checking it again
<pkhuong> rejecting requests is a fine load handling strategy. Is there actually
	  a problem?  [00:11]
<sykopomp> 1000 requests doesn't seem like a lot of load at all.  [00:12]
<pkhuong> sykopomp: concurrent?
<sykopomp> yeah
<stassats> pkhuong: with the git changes i do 1000 requests, it bails out after
	   a 100 or so, then i try to do 1000 requests again, and not a single
	   request succeeds  [00:13]
<H4ns> i've tested on osx with sbcl and siege and found it to be rather stable.
<Fade> does hunchentoot consume an FD for each req?
<sykopomp> a lot of webservers out there, including ones for scripting
	   languages, can handle C10k at this point.
<sykopomp> Fade: it consumes a thread, which is more serious than the FD issue.
<H4ns> Fade: for each connection.  [00:14]
<H4ns> sykopomp: hunchentoot in mt mode is not among those servers.
<Fade> 1000 sounds like you're running out of file descriptors due to ulimits
<sykopomp> No. It is not. In single-threaded mode, it can only handle a single
	   concurrent request, right?
<H4ns> sykopomp: correct.  [00:15]
<pkhuong> Fade: ISTM a more useful metric is how many requests it can serve per
	  seconds, and with what latency.
<pjb> And then, with all our mobil devices, you have to take into account
      relativistic drift:
      http://metrologyforum.tm.agilent.com/pdf/flying_clock_math.pdf
<H4ns> stassats: i can reproduce the "connection reset by peer" behavior
<pkhuong> that was for sykopomp even
<Fade> *nod*  [00:16]
<sykopomp> sure, I agree.
*** pjb (~t@81.202.16.46.dyn.user.ono.com) is now known as Guest7457  [00:17]
<pkhuong> Fade: what stassats's seeing is that after a few (less than a 1000)
	  requests under load, subsequent, non-concurrent, requests all fail.
									  [00:18]
<Guest7457> It's inacceptable: I had to reboot my emacs because linux updated it
	    and erased the old emacs version files.
<sykopomp> Guest7457: wrong channel  [00:19]
<H4ns> :D
<stassats> maybe apachebench is too blame, because wget requests come through
	   fine
<sykopomp> try httperf, too  [00:20]
*** Guest7457 (~t@81.202.16.46.dyn.user.ono.com) is now known as pjb`  [00:21]
<stassats> decreasing the number of concurrent requests in the subsequent trials
	   to 500 makes it work
<H4ns> interesting.  siege still works with no issues at all, ab fails like for
       stassats
*** pjb` (~t@81.202.16.46.dyn.user.ono.com) is now known as pjb
<stassats> work as in 137 requests succeed  [00:22]
<sykopomp> siege/httperf/ab all gave me different results based on their mood.
<H4ns> very strange condition indeed.  well, maybe mathieu can figure it out.
									  [00:23]
<pjb> About GPS, wikipedia says: If general relativity were not accounted for, a
      navigational fix based on the GPS satellites would be false after only 2
      minutes, and errors in global positions would continue to accumulate at a
      rate of about 10 kilometers each day.  [00:25]
<pjb> So obviously, they also have to take that into account on all the
      computers in space and on other planets.
<bjorkintosh> they are all on galaxynet aren't they?  [00:46]
<pjb> I don't think russian computers are on it.  But otherwise, AFAIK all the
      recent USA ones are on the IPN.  [00:50]
<pjb> But I guess for now it's mostly ad-hoc connections.  [00:51]
<pjb> More like uucp than IP.
<bjorkintosh> i think it is more along the lines of Xmodem/kermit  [00:53]
<phadthai> wbooze: there was some issue with the mutex implementation as well
	   which was apparently fixed since.. I've not had issues with the
	   netbsd-based center here, but the set software in use is restricted
	   too (mysql also had some issue, and is unused there)  [00:54]
<phadthai> wbooze: or rather, futex implementation
<Forty-3> I'm having trouble implementing lzm: http://fpaste.org/7uHc/  [00:55]
<Forty-3> I'm following
	  http://www.maximumcompression.com/compression_faq/compfaq_part2.php
<Forty-3> when I run it, I get a bunch of NILs
<Forty-3> does anything jump out at you?  [00:57]
<|3b|> formatting jumps out :/  [00:58]
<Forty-3> what about?
<|3b|> tabs instead of spaces, (w (db ...)) on one line is confusing (thought it
       was 1 var W initialized to an array instead of 2 vars)  [00:59]
<|3b|> DO starts a new LOOP clause, so put it at the beginning of a line instead
       of the end of previous line  [01:00]
<Forty-3> ok
<Forty-3> wait
<Forty-3> oh, nvm
<|3b|> and you can bind variables in LOOP, so i'd do that instead of DO (LET
       ...)
<Forty-3> ok
* |3b| would move the conditional into the LOOP too  [01:01]
<Forty-3> how would I do that..?
<phadthai> loop is fun
<|3b|> (loop ... if (...) do ...
<Forty-3> ah
<phadthai> Forty-3: look at with, for, if, when, until, etc
<Forty-3> wait, but then how do I get the else clause?
<phadthai> the hyperspec has a reference of all loop keywords  [01:02]
<phadthai> bbl
<|3b|> if ... do ... else do ...
<Forty-3> the hyperspec is so confusing...
<Forty-3> hm  [01:03]
<Forty-3> loop looks decidedly not like lisp
* |3b| would expect that function to return a single NIL, not a bunch of them
* |3b| actually likes that feature of LOOP
<|3b|> much easier to distinguish the flow-control logic from the actual work
       that way  [01:04]
<stassats> Forty-3: loop is in lisp, how can it look not like it?
<bjorkintosh> Forty-3, it is from the not-so-functional part of CL
<Forty-3> it's too much like format
<bjorkintosh> it is a macro.
<Forty-3> true
<Forty-3> one monster of a macro...
<bjorkintosh> also, do not forget that CL is a multi-paradigm language.
<Forty-3> well, yes
<bjorkintosh> see what i did there? I used a buzzword! :)  [01:05]
<|3b|> LOOP is harder to deal with from code though
<|3b|> some people prefer ITERATE, which is a sexp-based version of LOOP (with
       some extra features and specified way to extend it)
<|3b|> also, (cons k NIL) should probably be (list k)  [01:06]
<Forty-3> ok, now it looks like http://fpaste.org/MWjO/
<|3b|> WITH in loop only assigns when entering the loop, you probably wanted FOR
       there  [01:07]
<Forty-3> ok
<Forty-3> will that conflict with the other for?  [01:08]
<|3b|> no
<Forty-3> k
<|3b|> you can have as many as you want of most LOOP clauses
<Forty-3> how does it know what to loop with?
<|3b|> for = doesn't terminate iteraTion
<Forty-3> ok
<|3b|> and if multiple FOR clauses have termination tests, it just checks all of
       them and ends when any of them are true  [01:09]
<stassats> your indentation is way off
<|3b|> same with the termination tests outside of FOR clauses
<|3b|> you don't need PROGN inside a DO clause
<Forty-3> ok  [01:10]
*** PuercoPop (~PuercoPop@190.237.7.137) is now known as Guest35268
<Forty-3> so now it looks a bit different
<Forty-3> but it still does the same thing
<|3b|> and LOOP doesn't return anything unless you use certain clauses (like
       RETURN or ALWAYS)
<Forty-3> don't care if it returns anything  [01:11]
<Forty-3> notice the print
<|3b|> or if you use (RETURN ...)
<Forty-3> which is currently outputting NIL
<|3b|> ah, not quite how i interpretted the original question  [01:12]
*** Guest35268 (~PuercoPop@190.237.7.137) is now known as PuercoPop
<|3b|> well, what happens on the first character?  [01:14]
<Forty-3> NIL
<|3b|> i mean think about what the code does
<Forty-3> ah
<Forty-3> "be the interperter"  [01:15]
<|3b|> x is a string containing the first character, and w is NIL, and DB is
       empty, right?
<stassats> even if it weren't empty, EQL won't compare the strings the way you
	   expect it to
<|3b|> true
<stassats> minion: please tell Forty-3 about PCL  [01:17]
<minion> Forty-3: have a look at PCL: pcl-book: "Practical Common Lisp", an
	 introduction to Common Lisp by Peter Seibel, available at
	 http://www.gigamonkeys.com/book/ and in dead-tree form from Apress (as
	 of 11 April 2005).
<Forty-3> stassats: I'm reaqding that atm, but thanks anyway
<Forty-3> hm
<Forty-3> I think that
	  http://www.maximumcompression.com/compression_faq/compfaq_part2.php
	  has it backwards
<Forty-3> gah  [01:18]
<Forty-3> reversing it does the same thing
<Forty-3> er  [01:19]
<Forty-3> now it just outputs NIL
<|3b|> actually, maybe stassats is right
<Forty-3> hm
<stassats> at least add :test #'equal to find and position  [01:20]
<Forty-3> could be a typo
<Forty-3> stassats: hm?
<pjb> |3b|: well a progn in a do let emacs nicely indent that body.
<|3b|> pjb: indents properly without it for me  [01:21]
<pjb> Not here.
<pjb> do (form1)
<pjb> (form 2)
<pjb> instead of
<pjb> do (form1)
<pjb>    (form2)
<stassats> mine does the latter
* |3b| gets the latter
<pjb> slime doesn't like me.  [01:22]
<|3b|> possibly need to load the indentation contrib?
<Forty-3> stassats: what does that do?
<pjb> I have it.
<stassats> clhs find
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_find_.htm
<|3b|> Forty-3: most things use EQL for comparison by default, which checks for
       identity
<|3b|> Forty-3: and most strings with the same contents are not the same string,
       so don't have the same identity  [01:23]
<Forty-3> so I need to change it to equivlance, correct?
<Forty-3> huh?
<|3b|> using a :test of #'equal or #'string= test for same contents instead of
       same object
<Forty-3> so strings are not immutable?
<stassats> clhs 17.2.1
<specbot> Satisfying a Two-Argument Test:
	  http://www.lispworks.com/reference/HyperSpec/Body/17_ba.htm
<|3b|> strings are mutable
<pjb> Forty-3: some strings are mutable.
<stassats> Forty-3: that's irrelevant
<Forty-3> eh  [01:24]
<pjb> "immutable"  (make-array 7 :element-type 'character :initial-contents
      "mutable")
<|3b|> (though they might also be literals, in which case mutating them would be
       nonconforing code)
<|3b|> strings you make with CONCATENATE will all be new objects though  [01:25]
<Forty-3> stassats: thanks  [01:27]
<Forty-3> now it partially works  [01:28]
<Forty-3> hm  [01:31]
<pjb> Forty-3: you should probably read
      http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch  [01:32]
<pjb> I don't see any dictionary in your code.
<pjb> It is horrible, in time complexity.
<pjb> There's also http://www.youtube.com/watch?v=5IFQLvP_MZA  [01:33]
<Forty-3> pjb: db
<pjb> It's a vector, not a dictionary.  [01:34]
<pjb> Try (make-hash-table) instead.
<pjb> Don't search the string twice in it! position returns nil when it's not
      found.
<pjb> Just use gethash which also returns nil when not found.  [01:35]
<Forty-3> pjb: so?  [01:36]
<pjb> Instead of concatenating prefixes of your input, you could use subseq or
      even better: nsubseq.
<Forty-3> why does it need to be a hash table?
<Forty-3> oh, I see  [01:37]
<pjb> so find + position is ludicrous O(2n). position is riduculous O(n),
      gethash is nice O(1).
<Forty-3> yes, yes, I know about searching
<Xach> https://github.com/xach/skippy/blob/master/lzw.lisp#L39 has the lzw i use
       for writing gifs  [01:38]
<Forty-3> pjb: wait, so I can output the index of something in a hash table?
									  [01:40]
<Xach> powering e.g. http://wigflip.com/signbot/
<pjb> Forty-3: you can IN put an index in a hash-table.  [01:44]
<pjb> (let ((counter -1))  (setf (gethash word dict) (incf counter)) â€¦)
<Forty-3> pjb: huh?  [01:58]
<ghast> hi. is it possible to assign a value (with setf) to a struct member via
	a function that returns a member?  [02:02]
<stassats`> ghast: not really  [02:03]
<ghast> oh.
<stassats`> slot-value isn't specified to work on structures
<stassats`> now, your implementation may do it
<ghast> i tried doing something like (setf (function-that-returns-member
	my-struct) value) and it failed  [02:04]
<stassats`> on, no, that's not going to work at all
<ghast> i see.
<ghast> should i abandon structs and use CLOS then?  [02:05]
<stassats`> the function-that-returns-member may return a slot-name, and then
	    you'd use (setf (slot-value (function-that-returns-member my-struct)
	    my-struct) value) (not guaranteed to work)
<ghast> oh i'll try that
<stassats`> but what are you trying to do?  [02:06]
<stassats`> and yes, CLOS is more suited for this
<ghast> i was playing around with structs to practise  [02:07]
<stassats`> you can also just return accessors
<ghast> i wanted to see if instead of directly setting a member i could use a
	proxy function to get a member and set that instead
<stassats`> (lambda (x) (setf (my-struct-slot my-struct) x))
<stassats`> and then that'd be (funcall (function-that-returns-member my-struct)
	    y)  [02:08]
<stassats`> or you can do all the setting inside function-that-returns-member
	    altogether
<ghast> and that lambda would be the function-that-returns-member?
<stassats`> ghast: returned by it
<ghast> yeah i see
<ghast> so instead i would have a function-that-returns-member-returning-lambda
									  [02:09]
<stassats`> yes
<ghast> oh very interesting
<stassats`> there are many possibilities
<ghast> i'll try that ...
<ghast> i didn't thought about doing it like that way
<ghast> nice
<ghast> hey thanks
<didi> I'm following pjb advice and wrapping some foreign functions with Lisp
       ones and (declare (type ...)). You know, this type thing is a nice
       feature.  [02:10]
<stassats`> didi: declare type is not a way to make it more secure  [02:11]
<stassats`> clhs check-type
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/m_check_.htm
<didi> stassats`: No?
<didi> Oh.
<didi> stassats`: Thanks.
<stassats`> didi: no, it just becomes undefined what happens when you pass
	    something not conforming to the type  [02:12]
<didi> oic
<stassats`> sbcl signals a type error
<didi> Yeah, much better. :^)
<didi> stassats`: that's what I was seeing.
<stassats`> in the recent post on planet.lisp.org, ccl was overflowing a
	    declared fixnum silently
<stassats`> ((lambda (x) (declare (fixnum x)) (incf x) x) most-positive-fixnum)
	    => -1152921504606846976  [02:14]
<stassats`> or even ((lambda (x) (declare (fixnum x)) (incf x) x) (1+
	    most-positive-fixnum)) => #<BOGUS object @ #x30200191AF95>
									  [02:15]
<stassats`> adding (optimize safety) gets you an error  [02:16]
<pjb> ghast: a function can return a closure that does the setf for you.
<Forty-3> how do I convert a character to its numeric equivlant?  [02:17]
<pjb> Notice that there may not be a (function (setf struct-slot)), it's
      implementation dependent.
<pjb> Forty-3: code-char char-code
<stassats`> clhs char-code
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_char_c.htm
<stassats`> pjb: i believe somebody already suggested returning a closure
<pjb> Yes, I've got some time lag, not the same planet.
<stassats`> figures  [02:18]
<stassats`> clhs digit-char-p  [02:19]
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_digi_1.htm
<stassats`> for numerical characters
<pjb> stassats`: right.  But when you add the context of lzw, you only think of
      char-code. :-)  [02:20]
<Speaker> Hello.  [03:33]
<Speaker> Does anyone know how to make SLIME look like Lispbox's slime?  [03:34]
<stassats`> how does lispbox's slime look?
<Speaker> My current prompt, is my lisp prompt.  [03:35]
<Speaker> It looks like this: *
<stassats`> Speaker: do you want (slime-setup '(slime-fancy)) in your .emacs?
									  [03:36]
<Speaker> Exactly.
<Speaker> Thanks sir.
<ghast> pjb, stassats : regarding my previous question (about setf'ing the value
	of a struct member returned by a function), an easy way was to modify
	the function to return the name (symbol) of the member, instead of the
	member itself, then use (setf (slot-value my-struct
	(function-that-returns-struct-member-name)) newvalue).  [03:40]
<wbooze> hey http://paste.lisp.org/display/131193  [03:41]
<stassats`> ghast: it's not standard
<ghast> isn't it?
<stassats`> ghast: unfortunately  [03:42]
<stassats`> wbooze: because it's wrong?
<jfe> hi all
<ghast> is slot-value not standard? or is setf'ing a slot-value not standard?
<wbooze> stassats explain please i don't get it!
<stassats`> wbooze: did you write it?
<stassats`> ghast: slot-value on structures  [03:43]
<stassats`> clhs slot-value
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_slt_va.htm
<wbooze> it actually prints hello, but after giving me something like a kernel
	 index for string out of bounds error or sometimes a 5 is not a (mod 5)
<stassats`> see the last paragraph in the description
<ghast> but it says "The macro setf can be used with slot-value to change the
	value of a slot. "  [03:44]
<didi> wbooze: Why are you comparing with "?
<stassats`> wbooze: well, think about it, it goes out of bounds, which means it
	    doesn't terminate
<stassats`> look at your termination clause carefully
<stassats`> and now back to the string, where the hell do you see a #\" in it?
<wbooze> cause comparing it with #/o terminates it there which gives me only
	 hell and not hello
<didi> wbooze: Hehe, " is not part of the string.  [03:45]
<stassats`> wbooze: are for real?
<stassats`> are you
<didi> wbooze: Unless you do something like "foo\""
<wbooze> oh
<wbooze> well no no i know it's not part of the string  [03:46]
<wbooze> what's the terminating char of a string then ?
<stassats`> ghast: i meant exceptional situations
<ghast> stassats`: exceptional situations? what would be an exceptional
	situation? i don't understand.  [03:47]
<stassats`> ghast: the paragraph
<didi> wbooze: There is none.
<didi> wbooze: You're thinking of C.
<stassats`> the last paragraph of the exceptional situations section
<ghast> stassats`: aah that paragraph, i see it. Yes, actually i know that that
	case can not happen because of the way it is coded. However, it's okay
	if it explodes or goes undefined if the slot is missing.  [03:49]
<stassats`> ghast: no, it's not about missing slots
<stassats`> it's about slot-value
<ghast> i mean, when there is no such slot, like a struct with members 'x 'y 'z
	and you try to access member 'w
<stassats`> read the whole section carefully, the last paragraph is not about
	    missing slots  [03:51]
<ghast> you mean the "The specific behaviour dpeends on object's
	metaclass. [...]" part?  [03:52]
<stassats`> yes
<ghast> does that apply even to the case in which the slot-name exists?  [03:54]
<stassats`> i'm telling you for the third time, it's not about missing slots
									  [03:55]
<stassats`> what happens to the missing slots is described in the previous
	    paragraphs
<ghast> yes, i see.
<stassats`> it may be confusing, but it clears the confusion, because it says "
	    An error is never signaled if object has metaclass standard-class",
	    while the previous paragraphs say that it does signal, via
	    slot-missing function  [03:56]
<stassats`> but all existing implementation allow slot-value to be used on
	    structures  [03:57]
<ghast> is the metaclass something which depends on the implementation?  [03:58]
<stassats`> clhs glossary/metaclass
<specbot>
	  http://www.lispworks.com/reference/HyperSpec/Body/26_glo_m.htm#metaclass
<stassats`> the metaclass defines the behaviour of classes, the behaviour of
	    standard-classes is defined by the Meta Object Protocol, which many
	    implementations implement  [04:00]
<stassats`> structure-class is not described anywhere, so it may do whatever it
	    wants
<ghast> so it boils down to that
<stassats`> well, turns out the implementations chose to make them similar, so
	    it works  [04:01]
<pjb> ghast: structures _could_ be implemented as CLOS object, but since CLOS
      was specified long after structure existed, structures are often
      implemented differently.  [04:16]
<pjb> ghast: furthermore, you can also have (defstruct (s (:type list)) â€¦) or
      (defstruct (s (:type vector)) â€¦), and to access these you need to use the
      functions provided by defstruct.  [04:17]
<pjb> ghast: so you could pass the name of the reader or writer, but it's
      simplier and safer to just pass a closure.  [04:18]
<pjb> Or just use CLOS classes instead of structures.
<ghast> my idea was to use this function as both a reader of a member, and also
	to be setf'able  [04:19]
<pjb> ghast: you can also write your own defstruct macro to define all the
      accessors you want.  [04:20]
<pjb> ghast: so, what's your real problem? What do you want to do?  [04:21]
<ghast> i just wanted to emulate the behaviour of what i sometimes do in C,
	passing a pointer to a member, this way you can both read and write it,
	without actually even knowing which member it is
<ghast> notice, i'm only toying around, i want to learn some CL, no serious
	stuff here  [04:22]
* didi likes to use opaque stuff  [04:25]
<pkhuong> ghast: pass functions around.
<pkhuong> ghast: that'll even work with arbitrary places.  [04:26]
<ghast> a silly example ... say i've got a struct of members x and y (integers),
	and i want a function that returns a random member ... how could i do
	it?  [04:27]
<stassats`> you map integers to members in some way and the call random  [04:28]
<stassats`> and they're not members, they are slots  [04:29]
<ghast> ok, slots.
<pjb> ghast: see also
      http://www.informatimago.com/articles/usenet.html#Improved-DEFSTRUCT-macro--run-time-access-to-the-fields
<pjb> ghast: passing "pointers" is done with closure in lisp.
<ghast> ooh.
<pjb> galdor: See also
      http://www.informatimago.com/articles/usenet.html#C-like-pointers-in-Lisp
									  [04:34]
<pjb> Of course, usually we don't use something like & and deref, because those
      are low-level tools, not abstractions.
<pjb> For example, we may use things like Cells
      http://common-lisp.net/project/cells/ or the KR object system
      http://www.cliki.net/KR  [04:35]
<pjb> The problem also with having such a reference to random places, is that
      you will use it to modify this place, so you will have non obvious
      mutations.  This is not good in the functional style.  [04:36]
<didi> I'm guessing CLISP doesn't like when a foreign library uses threads too?
       Anyway, now I have callbacks working with SBCL. It's a beautiful thing to
       see.  [04:43]
<phadthai> didi: for various implementations I know that support threads,
	   libraries that create threads should "register" those threads to the
	   lisp runtime system in general  [04:47]
<phadthai> also that way for various other embedded languages like mozilla
	   spidermonkey  [04:48]
<didi> phadthai: I see. That's a problem for CFFI, for example, no? I mean, now
       you can't just use any foreign library.  [04:53]
<pjb> Yes, FFI is a problem.  [04:54]
<didi> pjb: Indeed.
* |3b| would only expect it to matter if the foreign thread makes callbacks to
  lisp code, but it is a problem in that case
<pkhuong> didi: I really hate libraries that not only use callbacks, but also
	  call them in arbitrary contexts.
<pjb> Rewrite those libraries in Lisp, or port Zeta-C to Common Lisp, or
      implement a C compiler targetting lisp.
<pkhuong> that's a problem even in C.  [04:55]
<pjb> Indeed.
<phadthai> sure
<phadthai> and there's the whole processes vs threads debate  [04:56]
<|3b|> pjb: not every library comes with source, and not every source of
       callbacks from foreign threads is a 'library'
* |3b| suspects trying to run a whole OS in zeta-c or other lisp-targetting c
  compiler wouldn't help much  [04:57]
* didi discovers C-c C-u (Achievement Unlocked)  [05:03]
<wbooze> so anyone gotta clue what's wrong with my example ?
<pavelpenev> c to cl compiler: https://github.com/vsedach/Vacietis
<didi> wbooze: We already told you.  [05:04]
<wbooze> apparently i can't get beyond the string index !
<didi> Yes.
<wbooze> so i have to add it with something like (last "string") ? back ?
<stassats`> what?
<wbooze> i was disconnected sorry  [05:05]
<wbooze> maybe i didn't get it
<didi> wbooze: Why don't you look for (>= i (length string))?
<didi> wbooze: I would use `loop' for what you're doing, but still.
<stassats`> wbooze: do you realize how stupid is checking for (last string)?
									  [05:06]
<stassats`> didi: i would use (princ string)
<didi> stassats`: Hehe.
<didi> Presumably they want to iterate over the string.
<wbooze> didi: i did (>= idx (length str)) in my do loop, but it's still failing
									  [05:07]
<stassats`> should be (= idx (1- (length str)))  [05:08]
<wbooze> like in here http://paste.lisp.org/display/131194
<didi> wbooze: Listen to stassats`.  [05:09]
<stassats`> well, it won't print the last character
<pjb> |3b|: a lot of C libraries could be compiled and run correctly on a CL VM.
      Nowadays, almost all the libraries you use are written in portable C, and
      generally don't do anything bad. (or else, they'd be security holes or
      would otherwise be rejected by distributions for bad coding quality).
									  [05:10]
<didi> wbooze: That's how I would do it: (loop for c across "hello" do (princ
       c))
<stassats`> (let ((str "hello")) (do ((idx 0 (1+ idx))) ((= idx (length str)))
	    (princ (char str idx))))
<stassats`> or (princ "hello") or (mapc #'princ "hello"), or (loop for char
	    across string do (princ char))  [05:11]
<|3b|> pjb: not sure that is as true of the things i've seen that want to run
       callbacks from arbitrary threads... windows has no source and wouldn't be
       in linux distros anyway, high-performance opengl drivers have no source
       and aren't in distros, fuse and sound drivers probably are in distros and
       have source, not sure they would like a CL VM though  [05:13]
<didi> wbooze: I personally would avoid having to deal with boundaries and use
       things that deal with them automatically, like `dolist', `map' and
       friends.
<pjb> wbooze: (let ((str "hello")) (do ((idx 0 (1+ idx))) ((>= idx (length str))
      (terpri)) (let ((char (char str idx))) (princ char))))  [05:14]
<stassats`> or (let ((str "hello")) (dotimes (i (length str)) (princ (char str
	    i))))  [05:15]
<pjb> |3b|: I'm talking about normal libraries: xml parsers, libusb, gtk, etc.
<|3b|> pjb: right, but i thought we were supposed to just rewrite those in lisp
       :)  [05:16]
<pjb> Well, the idea here is that you could avoid rewriting them in lisp, if you
      have a good C-to-CL compiler.
<stassats`> |3b|: anything to avoid getting things done
<pjb> For example, the non-debuggability of C thru FFI would be avoided.  [05:17]
<didi> GTK uses threads.
<didi> At least it is linked against it.  [05:18]
<didi> It has also a whole mechanism to allow calls to not freeze the interface.
									  [05:20]
<didi> Presumably using threads.  [05:21]
<pjb> Yes, but if you compiled it, instead of using the unix pthread library,
      you'd use bordeaux-thread under the pthread API.  [05:22]
* didi likes that
<pjb> So C libraries using threads compiled with your c-to-cl compiler using
      your C standard libraries implemented in CL would be entirely compatible,
      safe and debuggable as any other CL code.
<wbooze> and why is this http://paste.lisp.org/display/131195  [05:29]
<wbooze> the type error makes me mad!  [05:30]
<stassats`> you're not listening to anyone, are you?
<wbooze> dude, do is broken then ?  [05:41]
<wbooze> why the second let with char when it's already contained in the var
	 list of do ?
<wbooze> heh ?  [05:42]
<wbooze> and even do* does not alter anything there
<didi> wbooze: I think you misunderstood do*.
<Bike> you assign do to zero, and then to the length of the string.  you have
       example code to do what you want right here in the channel, exactly.
<didi> (idx 0 (length str)) doesn't seem right.  [05:43]
<wbooze> huh ?
<wbooze> (idx 0 (length str) and (char (char str 0) (char str idx)) should both
	 be acceptable as variables with var-name init step format  [05:44]
<Bike> yes, but the step is what the variable is changed to.
<Bike> and, code: Â«(do ((idx 0 (1+ idx))) ((= idx (length str))) (princ (char
       str idx)))Â» it's right up there.  [05:45]
<didi> pjb: By "C standard libraries" you mean libc, for example?  [05:48]
<wbooze> oh man, do is really broken  [05:49]
* moore33 never uses do anymore; loop rules.  [05:50]
<organixpear> I'm working with Embeddable common lisp and can't seem to uncover
	      why I can't use/find the "for" function. Can anyone enlighten me?
									  [05:51]
<Bike> The for function where?
<wbooze> i don't think i misunderstood the syntax if that's it
<organixpear> like "for i in * ; do echo $i ; done" but in an (iterate:iter (for
	      ...) lisp context  [05:52]
<wbooze> (do ((var init step) (var init step)) ((test)) blah)
<didi> organixpear: Do you have to use `iterate'?
<Bike> organixpear:
       http://common-lisp.net/project/iterate/doc/Numerical-Iteration.html#Numerical-Iteration
<organixpear> not it's not absolutely neccessary
<kennyd> organixpear generally you would do something like this: (use-package
	 :iterate). then (iter (for x in list) (print x))  [05:53]
<Bike> wbooze: yes, the step is the step.  you have the step as the constant
       length of the string, which is wrong.  and you have the working code
       example right there.  [05:54]
<organixpear> yes i know, however, when I enter a command like that ecl
	      interpreter reports back that "for" is not defined.
<stassats`> should be iter:for  [05:55]
<kennyd> organixpear you missed (use-package :iter)  [05:56]
<pjb> organixpear: (loop for i from 1 to 10 by 20 do (print i))  [05:57]
<didi> I would avoid dealing with packages. It took me a long time to get my
       head around some of it.
<pjb> wbooze: you could use my stepper to see how a macro works, but you'd have
      to redefine it in a package that uses cl-stepper instead of cl, since
      macros use symbols interened in their definition package.  But usually,
      it's enough to read the documentation of the macro to understand when and
      in which lexical scope each subform is executed.  [06:03]
<organixpear> loop for works  [06:06]
<organixpear> wonder what the deal is with iterate
<stassats> you were told countless times!
<stassats> you're using the wrong symbol!  [06:07]
<Petit_Dejeuner> I'm trying to follow along in an AI book, but I can't seem to
		 get a proper matching function made. It's either not letting me
		 use numberp as a function or I'm screwing something else
		 up. Does anyone know what might be wrong with this?
		 http://pastebin.com/MiPHPAAR
<Petit_Dejeuner> Error: APPLY: #'NUMBERP is not a function name; try using a
		 symbol instead
<didi> Petit_Dejeuner: Is it PAIP?
<Petit_Dejeuner> PAIP?
<stassats> Petit_Dejeuner: #'NUMBERP is a list, indeed
<didi> Petit_Dejeuner: The book, I mean.
<stassats> Petit_Dejeuner: you need to get it evaluated, or use a symbol instead
<Petit_Dejeuner> didi, The Elements of Artificial Intelligence Using Lisp
									  [06:08]
<didi> Petit_Dejeuner: Oh, never mind.
<Petit_Dejeuner> stassats, Why won't apply work? Doesn't it take a symbol for
		 its function?
<stassats> Petit_Dejeuner: try (match '(1 2 3 (? numberp)) '(1 2 3 4))
<Bike> you're not giving it a symbol, you're giving it #'numberp, which is
       (function numberp), a list.
<Petit_Dejeuner> oh  [06:09]
<stassats> and why is there (apply #'princ )?
<pjb> or (use-package  :com.informatimago.common-lisp.cesarum.pmatch) (match '(1
      2 3 (?x numberp)) '(1 2 3 4))  [06:11]
<pjb> ah no, pmatch doesn't seem to call a predicate.  [06:12]
<organixpear> thank you everyone for your help  [06:20]
<organixpear> I can now use iter and for  [06:21]
<wbooze> hmmmmmm  [06:26]
<wbooze> i don't get it with the constant-length thing of the variable you
	 mention....i think i know what you mean just vaguely....  [06:27]
<stassats> wbooze: first iteration i is 0, next iteration it's (length string),
	   and the next it's also (length string), and so on  [06:28]
<stassats> why are you using DO if you can't grok it?
<wbooze> i thought i had understood all, until the constant expression part!
									  [06:30]
<wbooze> hmmmmm
<Bike> ignore that then
<Bike> I meant "constant" because the length of the string isn't changing, I
       could have been more clear  [06:31]
<stassats> you've used it correctly before that, and now you can't
<wbooze> var 0 (length var) hmmm  [06:32]
<wbooze> if var is length 5 it's (var 0 5) var init step so step is 5 o o
<wbooze> oO  [06:33]
<wbooze> lol
<wbooze> ok
<stassats> can you stop saying "lol" all the time?
<stassats> and hmmm
<Bike> and ellipses?
<wbooze> ok i'll try
<stassats> at least ellipses are in their own sentences  [06:34]
<stassats> not in their own, that is
<wbooze> i confused the (var init step) with (var begin end) for a thing like a
	 range() function  [06:35]
<wbooze> or so
<wbooze> that (char (char str 0) (char str idx)) was totally bogged, for at
	 least two reasons then  [06:38]
<wbooze> i got what i wanted with just one var in (let ((str "hello")) (do ((idx
	 0 (1+ idx))) ((= idx (length str))) (princ (char str idx))))
<stassats> somewhere i've already seen this code  [06:39]
<wbooze> i seen it with and extra let in the do
<stassats> 14:11:01 <stassats`> (let ((str "hello")) (do ((idx 0 (1+ idx))) ((=
	   idx (length str))) (princ (char str idx))))  [06:40]
<wbooze> ah ok i was referring to pjb's then  [06:41]
<wbooze> i must have skimmed yours
<wbooze> ok one more thing to add to my notes then  [06:42]
<wbooze> thank you
*** DDDP (~DaDaDOSPr@71-222-65-185.ptld.qwest.net) is now known as DaDaDOSPrompt
									  [06:47]
<jeti> looking for a start-stop-sbcl script on redhat  [06:59]
<didi> jeti: What do you mean?  [07:03]
<jeti> dumb sysadmins ask me to provide a foolproof way to restart the server
       with my lisp webxerver  [07:05]
<jeti> webserver  [07:06]
<didi> #!/usr/bin/sbcl --script\n(run-my-webserver)  [07:07]
<pjb> It's the same as with any other program.
<pjb> You can copy apache init file.
<jeti> thx  [07:10]
* didi <3 alist  [07:29]
<vlion> Hiya- looking at abcl and drakma with openjdk; getting an error related
	to not finding a com.sun.jna class. Does abcl not work with openjdk?
									  [07:41]
<stassats> vlion: it does work  [07:42]
<stassats> vlion: just can't load cffi
<stassats> do (push :drakma-no-ssl *features*)
<stassats> before loading drakma
<vlion> A'ight. Thanks. :)
<stassats> and you need a fairly recent svn version of abcl to get drakma
	   working
<vlion> Later than the latest release?  [07:43]
<stassats> yes, that's what i just implied
<vlion> Just making sure. Thanks.  [07:44]
<antonv> vlion: if you have ant, building ABCL is just invoking "ant". 5 minutes
	 and it's done
<stassats> 5 minutes? here's a dime, buy yourself a real compute!  [07:45]
<antonv> stassats: appox, I don't want to give vlion unnecessary hight
	 expectations  [07:46]
<antonv> stassats: how long it takes on your computer?
<didi> Yay, now I have signals and events working. Also, I can run my code many
       times (I don't know how many) in the same Lisp session without crashing
       it. And I've learned that `defcallback' is permissive with the lambda
       list, but I _will_ pay the price later. Such is the "wonders" of FFI.
<antonv> vlion: if you don't have ant but have maven - the same, just call "mvn
	 package"  [07:47]
<stassats> antonv: 2 minutes  [07:48]
<antonv> vlion: sorry, mavent is not supported, only ant
<vlion> My ever-useless work firewall won't let svn checkouts. Ah well. Don't
	worry about, it was an experiment. :)
<antonv> stassats: is it laptop or stationary box?  [07:54]
<stassats> antonv: a desktop, it's 2:12 on the laptop
<didi> Just to note, CFFI's manual is _very_ good. The examples were well
       thought. Many times you want to do something and the manual give it as an
       example somewhere.
<stassats> and it's not the latest and greatest, so it could be even faster
									  [07:55]
<antonv> 2:12?
<stassats> what can be possible not clear about 2:12?
<antonv> not clear at all for me, would you mind rephrase?  [07:56]
<stassats> 2 minutes 12 seconds
<antonv> ah, 2 minutes 12 seconds on the laptop? a good one, with SSD drive?
									  [07:57]
<antonv> it's a good property of ABCL is that it's easy to build  [07:58]
<antonv> ECL is also easy to build
<stassats> no, with a hard disk drive
<antonv> some other lisps require you to download and instals some libraries,
	 ECL has everything necessary in the repository
<stassats> abcl requires me to install a boatload of java crap  [07:59]
<antonv> a, yes
<antonv> i forgot about this, despite recently had experience installing java on
	 linux server in order to build ABCL  [08:00]
<p_l> ... boatload?
<pjb> Sure.  That's why there's clisp if you prefer to instal a boatload of C
      crap, or ccl if you prefer to load a boatload of lisp crap.
<p_l> ... ah. I forgot that stasssats went straight to "only work in CL nirvana"
<p_l> try building something with maven, see it download half the internet
<Xach> stassats has sent a number of fantastically helpful patches for abcl, so
       it's not like he has not used it.  [08:03]
<stassats> well, i actually haven't used abcl for anything real, other than just
	   testing code  [08:04]
*** sambio (~cc@190.57.227.107) is now known as sambio_  [08:05]
<p_l> Xach: I'm not saying he didn't. It's just that, comparatively speaking,
      ABCL is nice & easy to install  [08:15]
<stassats> well, i don't have use for java for anything else
<antonv> I have just started fresh recompilation and loading of all the ASDF
	 systems found in quicklisp by 7 CL compilers  [08:58]
<antonv> to collect results about what builds and what doesn't  [08:59]
<stassats> are you trying to increase entropy in the universe?
<antonv> to decrease
<stassats> breaking the laws of thermodynamics, i see  [09:01]
<antonv> stassats: to decrease in the sense that if I know what builds, I can
	 run it this test regulary and compare results and so detect any
	 regressions in whole QL
<antonv> stassats: i.e. to make the workability of the libraries less random
									  [09:04]
<stassats> Xach does compile everything before releasing, only not on all
	   implementations  [09:05]
<antonv> by SBCL only
<stassats> trying to compile things on, say, ABCL would prove to be a
	   frustrating experience
<antonv> for library developers and abcl authors - maybe, but not for me (i am
	 very unbiased)  [09:07]
<stassats> what would you do with that information?
<antonv> publish it
<antonv> people are interested in results, Juan Jose of ECL asked what compiles
	 and what doesn't  [09:08]
<Bike> isn't that what cl-test-grid is for?
<stassats> what's interesting about results?
<stassats> now, if you were going to file bug-reports or patches, that's much
	   better  [09:09]
<antonv> he wants to sort libraries by dependencies, and so find root blockers
	 (failing ASDF systems, which also block other systems)
<antonv> i.e. to see what systems is the most important to fix so that more code
	 work on ECL
<antonv> stassats: yes, i am going to submit bug reports when detect regressions
									  [09:10]
<antonv> Bike: yes it is
<stassats> sounds like it's better to fix all the bugs  [09:11]
<antonv> i have just modified cl-test-grid code collect results of loading every
	 library
<antonv> stassats: yes, but there are too many bugs now and it's impossible to
	 just go and report all of them, + some of the bugs are old and authors
	 are not available to fix (busy or not interested)  [09:12]
<stassats> fork it then!
<antonv> stassats: in case of regressions it's fresh change so authors are more
	 likely ot be available and interested to fix
<antonv> stassats: myself? for one person it's infinity amount of work to fix
	 every bug  [09:13]
<Quadrescence> stassats, you don't seem to have a pragmatic view. Most people
	       don't have the time or expertise to fix all of the compilation
	       bugs for all systems.
<antonv> if fixing bugs it would be good to decide what libraries are more
	 important  [09:14]
<stassats> Quadrescence: that doesn't sound like a good excuse  [09:15]
<antonv> there are lot of bugs, but some of the deserve to be fixed
	 (e.g. usocket, drakma, alexandria and similar base libraries)
<reactormonk> For tinkering with a new language, I sometimes like to write tests
	      and code in the same file and then run them all at once - what
	      kind of libs for testing would you recommend? the simpler, the
	      better  [11:19]
<reactormonk> ... until a certain limit  [11:20]
<didi> reactormonk: I like the one described in PCL:
       http://gigamonkeys.com/book/practical-building-a-unit-test-framework.html
<didi> It has 26 LOC.
<pjb> reactormonk: I write: (defun test/something () (assert (equal 'some-result
      (do-something))) â€¦ :success)  [11:21]
<didi> reactormonk: Although if your intention is "tinkering", the REPL is
       already pretty awesome.
<pjb> then just: (test/something) to test something.
<reactormonk> didi: I'd like some editor support as in emacs
<pjb> 0 LOC!  [11:22]
<pavelpenev> http://www.cliki.net/test%20framework quite a few of them exist,
	     not as many as utility libraries though :)
<reactormonk> didi: yeah, PCL looks good, except I'd like it without the
	      explicit combine-results  [11:23]
<didi> reactormonk: I see. Well, I just type crap in the REPL.
<reactormonk> didi: get annoying after a while.  [11:24]
<didi> NEVER!
<pavelpenev> reactormonk: if you're just tinkering, as you say, you'll be fine.
									  [11:25]
<reactormonk> didi: :-P  [11:26]
<Vivitron`> rt is another simple one. I'm not aware of a test library with
	    extensive emacs integration, assuming that you meant that in
	    particular and already use slime  [11:28]
<stassats> minion: stefil?  [11:30]
<minion> stefil: Stefil is a test framework, and its philosophy is to stay as
	 transparent as possible, disrupting the normal Lisp application
	 development process as little as possible. http://www.cliki.net/stefil
<xwolf-> what was that test framework that uses docstrings for testing purposes?
									  [11:32]
*** guyal_ (~michaelmu@108-235-117-64.lightspeed.sntcca.sbcglobal.net) is now
    known as guyal  [11:37]
<pjb> xwolf-: that would be a bad test framework.  [12:07]
<didi> So it turns out one /can/ use `define-foreign-type' of CFFI as a
       `defclass' with privileges. I hope this doesn't blow up later.  [12:26]
<xwolf-> pjb why?
<pjb> xwolf-: if you wanted to adjoin the test cases to the definition of the
      function, it would be better to do so with a declaration.  [12:46]
<pjb> (declaim (declaration test-case)) (defun f (x) (declare (test-case (eql 1
      (f 1)) (forall n (integer 1) (eql (* n (f (1- n))) (f n))))) â€¦)  [12:47]
<pjb> s/integer 1/integer 2/  [12:48]
<xwolf-> pjb interesting  [12:50]
<xwolf-> with docstrings though it could double as documentation, in the example
	 section  [12:52]
<pjb> The declarations can also be processed by a documentation generator.
									  [12:54]
<didi> Is it possible to make `princ' print in a new line?  [13:11]
<stassats> (princ #\Newline)
<didi> stassats: Thanks.  [13:12]
<stassats> or just (terpri)
<stassats> or just write-line for strings
<didi> `terpri'. That's new for me.  [13:13]
<didi> Ah, `write-line' is more appropriate for me right now.
<didi> Yay, I recreated GTK's "hello, world", with the exception of 'swap',
       which doesn't seem fun for such toy.  [13:16]
<didi> Now I have to read about 'trivial-garbage' as I'm leaking like I don't
       even care.  [13:20]
<stassats> how would you name your new gtk bindings?
<didi> stassats-gem  [13:21]
<stassats> but that's completely misleading
<didi> :^(
<reactormonk> I suppose emacs + slime is a way to go?  [13:36]
<didi> reactormonk: The best way to fly.
<reactormonk> :D  [13:37]
<pnpuff> flutter :)  [13:38]
<reactormonk> didi: what are the default key chains I need for my workflow
	      above?
<didi> reactormonk: Well, I have <http://paste.kde.org/539282/> in my ~/.emacs
									  [13:39]
<didi> reactormonk: Look for paredit too.  [13:40]
<reactormonk> got that already  [13:42]
<reactormonk> I'll probably rebind  [13:47]
<didi> reactormonk: Are you a VIM user?  [13:48]
<Vivitron`> C-c C-k (slime-compile-and-load-file) will be the big one. M-n/M-p
	    cycles through the compiler notes as you would expect
* didi uses C-c C-c all the time  [13:49]
<reactormonk> didi: I'm an evil user
<didi> reactormonk: oic
<reactormonk> didi: oic?  [13:50]
<didi> Oh I see. :^)
<stassats> reactormonk: that's curable  [13:51]
<reactormonk> stassats: nah, I like being evil  [13:52]
<didi> If I messed up with `defclass' and `initialize-instance', how can I make
       Lisp forget them? I'm not sure, but apparently `make-instance' is calling
       some old form of a CLOS class.  [14:23]
<didi> It's not `fmakunbound'.  [14:25]
<stassats> unintern works  [14:26]
<Bike> (setf (find-class ...) nil)?
<stassats> unintern is easier
<Bike> probably.
<didi> Oh right!  [14:27]
<didi> Thank you.
<didi> Restarting Lisp was getting very tiring.  [14:28]
<didi> Vivitron`: Thanks for the C-c C-k. It's my new C-c C-c.  [15:05]
<reactormonk> didi: just remap?  [15:20]
<didi> reactormonk: Nah, I like both and they are both easy to hit.  [15:22]
<stassats> didi: C-c C-c is better than C-c C-k most of the time
<didi> stassats: Sure. But I'm doing a lot of query-replace and C-c C-k is very
       handy.  [15:23]
<trebor_dki> hm, trying to figure how to use sb-ext:run-program with gnuplot, so
	     that gnuplots 'pause -1' works, i.e. user can interact with the
	     graph and then press a key to get to the next one ...  [15:57]
<didi> trebor_dki: You can open it with streams.  [15:59]
<trebor_dki> (sb-ext:run-program  path-to-gnuplot gnuplot-script-fname  :wait t
	     :input t :pty t) <-> *standard-input*?
<didi> :input :stream  [16:00]
<didi> :output :stream
<trebor_dki> didi: thanks, testing
<didi> trebor_dki: Be careful that if you don't use `force-output', things will
       freeze.  [16:01]
<trebor_dki> didi: hm, sorry, didn't understand :stream and force-output
	     ... googling.  [16:04]
<didi> trebor_dki: `force-output' is like flush.  [16:05]
<stassats> googling? what will google tell you?
<didi> clhs force-output  [16:06]
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/f_finish.htm
<trebor_dki> didi: i tried (sb-ext:run-program  path-to-gnuplot
	     gnuplot-script-fname  :wait t :input :stream :output :stream :pty
	     t), but obviously this was wrong (as i did not find anything about
	     :stream in
	     http://www.sbcl.org/manual/Running-external-programs.html
									  [16:09]
<stassats> clearly, using :streams with :wait t is pointless
<trebor_dki> why?  [16:10]
<didi> trebor_dki: Because you don't want to wait.
<stassats> trebor_dki: what are you trying to do?  [16:11]
<trebor_dki> i created a gnuplot-script to generate some diagrams, but the user
	     has to change x-range y-range to polish the graphs (normaly i do
	     this by using pause -1 and a replot afterwards)  [16:12]
<trebor_dki> after that the program creates a openoffice-document including the
	     diagrams
<stassats> what do you want to do with run-program?  [16:13]
<trebor_dki> so, i really would like to wait until gnuplot is finished.
<trebor_dki> run-program starts gnuplot.
<stassats> who would've thought!
<trebor_dki> is run-program the wrong way in this case?  [16:15]
<stassats> in which case? you haven't told what are you trying to do yet  [16:17]
<stassats> you use run-program, it demonstrates some behaviour, you want it to
	   behave in another way, describe it  [16:19]
*** Yuuhi`` (benni@p5483BFF8.dip.t-dialin.net) is now known as Yuuhi
<trebor_dki> i hoped (wrongly) that gnuplots terminal io could be redirected to
	     the repl, but as i see your questions this seems to be bascially
	     wrong.  [16:20]
<trebor_dki> so creating control-stream and then (sb-ext:run-program
	     path-to-gnuplot gnuplot-script-fname  :wait nil :input
	     gnuplot-input-stream :output gnuplot-output-stream :pty t)?
									  [16:22]
<stassats> (sb-ext:run-program "gnuplot" '(parameters) :search t :input t
	   :output t) will redirect the output and input
<trebor_dki> oh my, it is in the *inferior-lisp* (...) thanks  [16:26]
<trebor_dki> stassats: thanks, (i tried :input t before, but was looking in the
	     slime-repl-buffer).  [16:35]
<trebor_dki> whois stassats  [16:42]
<trebor_dki> sorry need some coffee  [16:43]
*** [SLB]` (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now
    known as [SLB]  [17:27]
*** tkd_ (~tomek@tlahuizcalpantecuhtli.wa.ht) is now known as tkd  [17:37]
*** Eyes|Infinite (~Eyes@WiseOS/Founder/EyesIsMine) is now known as EyesIsMine
									  [17:49]
*** [SLB]` (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now
    known as [SLB]  [18:07]
*** [SLB]` (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now
    known as [SLB]  [18:54]
<Bucciarati> http://www.youtube.com/watch?v=oPPEAcDCnSg  [19:13]
<Bucciarati> um, wrong channel
<H4ns> pjb: thanks for the raspi ccl instructions!  [19:31]
<woudshoo> /?  [20:02]
<wbooze> oh man, my #x1D400 to #x1D77F unicode range is screwed in sbcl  [20:25]
<wbooze> like this http://paste.lisp.org/display/131200  [20:26]
<wbooze> it's actually displaying like this
	 http://picpaste.de/pics/test-uni-IH3iguzH.1345897685.png  [20:28]
<wbooze> and it got converted via copy-paste somehow....
<woudshoo> Looks more like a terminal problem  [20:31]
<wbooze> hmmm, TERM=xterm on konsole  [20:32]
<wbooze> and kbd is in ascii mod  [20:33]
<wbooze> not utf or unicode
<woudshoo> Hm, i don't know what kbd is.  But sbcl will send characters encoded
	   in probably utf-8 to the terminal.  If the terminal does not
	   understand utf-8 or is set to latin-1 or something similar it will
	   mess everything up.  [20:36]
<woudshoo> Although it seems the other unicode characters are displayed
	   correctly.  So maybe your font does not have characters for code
	   points in the 1D400-1D7FF range?  [20:38]
<wbooze> ahh, so the terminal is not in utf-8 mode by default on my system
<wbooze> that maybe too
<wbooze> but i wonder why the partial output then!
<wbooze> and the stutterings
<wbooze> "A"" "BB" ?? for example...  [20:39]
<wbooze> tho the copy-pasted thing is displaying them correctly again
<woudshoo> Hm, yes.  Well 1D400 is more than 16 bits.  So maybe your terminal is
	   buggy and cannot handle code points over FFFF correctly?  Because of
	   the copy paste being correct, it seems that the generated byte
	   sequence by SBCL is correct.  [20:40]
<wbooze> is anyone able to get to that file here
	 http://static.boinkor.net/lisp/font-hackery.lisp
<wbooze> yes seems so  [20:41]
<wbooze> but it's konsole from kde, with default settings....
<wbooze> didn't do anything fancy with it
<woudshoo> Nope, I cannot access the url, it just waits until it times out
<woudshoo> Also, I have never used KDE and haven't used linux in ages.  So I
	   cannot help you there.  [20:42]
<wbooze> ok then it's not just me
<woudshoo> Sorry I cannot help you, but honestly, I am not suprised that
	   programs have bugs handling code points larger than FFFF  [20:44]
<wbooze> yeah, it works in the browser but no in terminals....weird....  [20:45]
*** [SLB]` (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now
    known as [SLB]  [20:49]
*** superflit_ (~superflit@67-41-148-52.hlrn.qwest.net) is now known as
    superflit  [21:21]
<wbooze> xfce's terminal is always display them like in the browser  [22:08]
<wbooze> only some glyphs are missing obviously...
<wbooze> like here http://picpaste.de/pics/test-uni1-hvAgQwfD.1345904293.png
									  [22:18]
<woudshoo> So the world makes sense again?  [22:22]
<wbooze> no not yet  [22:32]
<pjb> wbooze: now it's only missing characters in fonts.  [22:54]
<pjb> If you add fonts or switch to a more unicode-complete font, it should
      display the missing characters.
<wbooze> i tried to switch to -misc-unifont-**** blah but somehow it does not
	 work anymore....  [23:00]
<axion> terminus is a font with a lot of unicode covered, and designed for many
	hours of terminal work (lisping) per day :)  [23:01]
<wbooze> -gnu-unifont is more complete they say, but i only found a size 13
	 version of it on my slack  [23:02]
<axion> eww
<wbooze> yep
<axion> this is a bit off-topic, but ensure your font path is specified in
	xorg.conf, then run fc-cache -v, and (possibly?) restart X to pick up
	the changes  [23:03]
*** guyal_ (~michaelmu@108-235-117-64.lightspeed.sntcca.sbcglobal.net) is now
    known as guyal  [23:51]

[Sun Aug 26 2012]
*** sambio_ (~cc@190.57.227.107) is now known as sambio  [00:07]
*** sambio_ (~cc@190.57.227.107) is now known as sambio
*** [SLB]` (~slabua@host237-160-dynamic.9-79-r.retail.telecomitalia.it) is now known as [SLB]
											      [01:01]
<ivan-kanis> you guys were right, I rewrote my article on Lisp today and I feel it's better  [01:07]
<wbooze> dude, that wrap new font around clim-clx fonts does not work for me anymore....  [01:08]
<stassats`> ivan-kanis: imagine how much better would it be if you rewrite it again  [01:39]
<ivan-kanis> I let it sit for two weeks but I don't think I'll rewrite the whole thing, I am not a
	     masochist.  [01:40]
<ivan-kanis> I sent and e-mail to Ron Garret to get permission to quote him
<stassats`> quoting is fair use, you don't need permissions  [01:41]
<lammb> When using slime & having no Internet connection, is the best way to access package docs
	either the slime inspector or slime-describe-* functions? Or am I missing some tricks? These
	pacakges were installed with quicklisp.  [02:13]
<Guthur> how easy would it be to invoke SLIME functionality from a CL program?  [02:15]
<Bike> what do you want?  there's a lot in the swank system, and then there's eval-in-emacs.  [02:16]
<woudshoo> lammb: What fails if you do not have an internet connection?  [02:17]
<lammb> woudshoo: The ability to access webpages, i.e., I only have local docs, which isn't so much
	of a problem in Lisp I'm finding compared to other languages.  [02:19]
<stassats> Guthur: what slime functionality?
<lammb> woudshoo: Basically, I'd like a sanity check that I'm not being overly clumsy with my use of
	the doc facilities in slime/Lisp generally.  [02:20]
<Guthur> Bike, stassats:  M-. for one
<Guthur> I'm thinking of a game editor where I can jump to code behind an entity
<Guthur> things of that ilk
<woudshoo> lammb: Hm, yes, I think this is still an area up for improving.  I feel clumsy in such a
	   situation too.  I either use describe and apropos.  But what I also do a lot is look if
	   there is a doc directory in the installed package.
<woudshoo> lammb: For the last point, I typically do M-. on a symbol in the package (that at least
	   opens a buffer near the right directory) and navigate from there.  This should be easier,
	   but (un)fortunately, there is no standardized documentation system outside of docstrings.
											      [02:22]
<pjb> Guthur: easy enough: just a small google search away:
      https://www.google.com/search?q=site%3Apaste.lisp.org+pjb+slime+rpc  [02:23]
<Guthur> so basically I would like to be able to interactively design 'levels' within the game
	 environment but I do not want to totally detach myself from emacs
<lammb> woudshoo: Ah, thanks for the help. The system is fine for my needs, just wanted to make sure
	I wasn't missing some more convienient. (-:
<Guthur> pjb: neat, thanks  [02:24]
<woudshoo> lammb:  Well, we both might be missing something :-)  I haven't really searched hard for
	   a better mechanism.  [02:25]
<lammb> Anyone else get unformated error messages with slime/sbcl? This like Evaluation aborted on
	<blah blah "Unknown &KEY argument: ~S">. Is there something wrong with my env? Why isn't the
	~S getting substituted?  [02:31]
<wbooze> put the whole error message right after the first error on a pastebin  [02:32]
<wbooze> else nobody will be able to help you
<lammb> After quitting the debugger, the following one-liner is printed:
<lammb> ; Evaluation aborted on #<SB-INT:SIMPLE-PROGRAM-ERROR "unknown &KEY argument: ~S"
	{100786A383}>.
<wbooze> how did you quit it ?  [02:33]
<lammb> By pressing 'q'
<wbooze> 0 or :0 ?
<wbooze> huh ?
<wbooze> q ?
<lammb> Yes, the letter.  [02:34]
<Bike> lammb: that's normal, I think
<pavelpenev> q quits many things in slime
<Bike> if you want the actual error you have to return it
<wbooze> ah you in slime ok
<lammb> Bike: Grr. Thanks!
*** ghast` (~user@host83.190-30-155.telecom.net.ar) is now known as ghast  [02:37]
<wbooze> does anyone know the font-hackery.lisp file or has it to be pasted somehowere for me ?
											      [02:45]
<wbooze> cause my around methods seems todo nothing
<wbooze> cause i can't get to print the same chars in clim-listener like this
	 http://picpaste.de/pics/test-uni2-vzFyBjDv.1345920394.png  [02:47]
<Bike> you can use ~c to print chars directly  [02:48]
<wbooze> Bike: do you get me, it's working in the sbcl repl in terminal, but in in the repl in
	 clim-listener  [02:51]
<wbooze> but not*
<Bike> yes, but I know nothing about clim.
<wbooze> i'd assume it's a font issue, but trying to change the font several ways didn't succeed
	 here, and if it were font issue why would it print the other ranges ?
<wbooze> but just not that one ?  [02:52]
<wbooze> it's working for the other range for example like here
	 http://picpaste.de/pics/test-uni3-zGL85AS2.1345920810.png  [02:53]
<woudshoo> wbooze: there is a difference between the two ranges.  The case that does not work needs
	   4 bytes (in utf-8) to encode the values.  The other do not need that much.  So if the
	   receiver/displayer is a bit old (before they thought more than FFFF characters are a good
	   idea) it might misinterprete the byte sequences.  [03:02]
<wbooze> oh  [03:03]
<wbooze> it even prints the names of the glyphs like #\blah when i'm only using (code-char num) and
	 not (string (code-char num)) in that loop  [03:04]
<wbooze> just not the glyphs themselves...
<wbooze> would changing the default-external-format of the gui to utf-8 alter something in that
	 regard ?  [03:06]
<woudshoo> wbooze: Well, first of all, it seems that the display part and the lisp printing part
	   seem to agree on the encoding.  Otherwise your other range would be messed up.
											      [03:07]
<wbooze> yes
<woudshoo> wbooze: there are basically two options:  1 - you do not use utf-8, but UCS-2 in your
	   clim case.  2 - you do use utf-8 in the climm case  [03:08]
<wbooze> hmm, ok i'll try now
<woudshoo> wbooze:  Now in case 1 you can have better luck with setting it to utf-8.  HOWEVER, there
	   are two sides wich both need to speak utf-8. So the terminal or display part also need to
	   be changed to utf-8.  [03:09]
<woudshoo> wbooze: If you are in case 2.  You are probably out of luck.  You can try utf-16.  But I
	   wuld not expect it to work.
<wbooze> erm, kbd_mode tells me it's already in utf-8 mode and i have a lang env var set to
	 de_DE.UTF-8  [03:10]
<wbooze> only lc_collate is C
<wbooze> all other locales utf-8
<woudshoo> wbooze:  What is kbd_mode?  (lc_collate should not matter) Your listener is inside a
	   xterm?  [03:11]
<wbooze> no, only the sbcl repl is, from there i start the listener
<wbooze> kbd_mode utf8 means key-presses are sent as utf-8 encoded i think  [03:12]
<woudshoo> wbooze: so kbd_mode does not matter in this case.  Where does the listener live?  [03:14]
<wbooze> it's a clx app !
<wbooze> so X env
<woudshoo> wbooze:  Hm, yes, so that means that clx cannot handle those characters (I think.)
											      [03:15]
<woudshoo> wbooze: anyway, I just googled and it turns out that until very recently MySQL messed up
	   the characters outside the BMP (base plane) even when stored in utf-8.  [03:16]
<WarWeasle> Does anyone know offhand how to export an entire package from a package?  [03:17]
<wbooze> yes, i read something about that in clx backend that i'm on my own when using anything else
	 than iso-8859-1
<woudshoo> wbooze: Aside: All unicode characters < FFFF are in the base plane (MBP) the characters
	   that you are having trouble with are in plane 1 (unicode concepts.)  And generally
	   speaking only the MBP is relatively well supported.
<wbooze> yes, i got that too  [03:18]
<wbooze> and there are fonts which cover upto 16 planes or so
<wbooze> the only font covering mbp totally is unifont  [03:19]
<woudshoo> wbooze: But as you are finding out, having the fonts is only 1/3 of the equation
<wbooze> yes
<Bike> WarWeasle: including all the symbols it imports...?
<wbooze> i think it's a restriction on the clx backend site even not by clx itself....  [03:20]
<WarWeasle> Bike: Yes!  [03:21]
<WarWeasle> Bike: I'm using cairo from inside my package as if it were part of my package.  [03:22]
<woudshoo> wbooze: i guess you have to ask on a clx mailing list.  I have never used clx
<wbooze> ok
<wbooze> nvm, thank you for an attempt tho :)
<Bike> WarWeasle: oh, then just use the package.  (:use #:cairo) in your defpackage
<wbooze> it's a shame, shame, shame i tell you!  [03:23]
<WarWeasle> Bike: Does that export the symbols, too?  [03:24]
<woudshoo> wbooze: good luck!  clim is something i want to try one day, but it didn't work on my
	   mac:-(
<lammb> WarWeasle: No, it just modified the "inheritance chain" when resolving symbols from the
	package you use'd it from, IIUC.  [03:26]
<wbooze> oh
<Bike> WarWeasle: hm, you might want (do-external-symbols (s :cairo) (export s :yourpackage))... I'm
       not sure.
<didi> Exporting _all_ the symbols seems wrong to me, though. All those helper functions polluting
       the namespace...  [03:27]
<WarWeasle> didi: I'm extending cairo with pangocairo.  [03:28]
<Bike> didi: mine only does the external symbols
<didi> WarWeasle: You can all access intern symbols with ::
<lammb> didi: do-external-symbols doesn't export *all* symbols, only external ones.
<didi> Bike: I think they want _all_ of them.
<WarWeasle> Bike: I just want Cairo's external symbols. I just don't want bounce between cairo: and
	    qix:. I just want to use qix:.  [03:29]
<didi> Or maybe I misunderstood it.  [03:30]
<Bike> I think mine should work, then
<lammb> I still don't get why you'd want to export them if your extending Cairo.
<WarWeasle> Bike: Can I put that in my package file as a macro?
<Bike> as a macro?  [03:31]
<WarWeasle> Bike: Or runtime. I just didn't think it was code.  [03:32]
<WarWeasle> Bike: Testing it now
<didi> Ah, I think I understand it now. You want the symbols that you imported from a package appear
       to whoever import your package.  [03:35]
<WarWeasle> Bike: Look's like I'll just have a long package export.  [03:36]
<WarWeasle> didi: Yes, exactly.
<Bike> Sorry.
<lammb> USE is transitive, AFAIK.  [03:37]
<WarWeasle> Bike: Please don't be. You just saved me HOURS with your external-symbols function
											      [03:38]
<pkhuong> lammb: no, it's not.
<lammb> Well, it seems semantically to be the case
<lammb> When FIND-SYMBOL's second part is :inherited  [03:39]
<Bike> use-package imports all the external symbols of the package as internal symbols, yeah?  if
       warweasle wants to define a cairo interface that's not the needed behavior.
<lammb> So, if WarWeasle USE'd Cairo in his Pango-whatever, the people USE'ing Pango-whatever could
	access cairo externs, right?
<lammb> I thought that is how find-symbol is defined  [03:40]
<WarWeasle> lammb: Yes, without needing to remember which was cairo: and which was pango:
<lammb> I must be on the wrong page.. Apologies.
<WarWeasle> Anyway, problem is solved! I'm off to fight some more windmills!  [03:41]
<didi> WarWeasle: It's dangerous to go alone. Take these ()  [03:42]
<WarWeasle> didi: Elegant weapons...for a more civilized age.  [03:43]
<lammb> Bike: You confuse me (apologies for all this confusion, I'm brand new to Lisp today). The
	CLHS says "All external symbols in packages-to-use become accessible in package as internal
	symbols." But that doesn't necessarily means they're imported, right? They just become
	available thru inheritance.  [03:47]
<lammb> (in the case of USE-PACKAGE)  [03:48]
<Bike> lammb: oh, you're right.
<Bike> The using mechanism is separate from importation and all.  My mistake.  [03:49]
<lammb> And pkhuong, I mean if pkg B uses pkg C, and pkg A uses B, then semantically, A has used C,
	or have I misunderstood something? Can't tell if you ignored my continued ignorance, or were
	just being pedantic.  [03:51]
<Bike> well, used symbols aren't (necessarily) exported.
<lammb> Bike: Oh, of course. Thanks.  [03:52]
<lammb> Stop thinking about CL packages like ruddy Java classes and have your medicine.  [04:13]
<tidux> I have a question about (run-program) in common lisp  [04:27]
<tidux> if I use (run-program "w3m" :arguments '("file:///home/foo")) it works  [04:28]
<tidux> but if I use (run-program "w3m" :arguments '("/home/foo")) it doesn't
<pjb> Each implementation has its own variant of run-program.
<tidux> it's clisp
<Sgeo> What happens if, at the shell, you try w3m "/home/foo"?
<pjb> It doesn't look like a lisp question, but a w3m question.
<pjb> Have you ever read the manual of w3m???
<tidux> Sgeo: works fine from the shell  [04:29]
<tidux> and yes, pjb
<pjb> It doesn' tmatter.
<pjb> it's not a lisp question.
<tidux> I was having the same problem with lisp
<tidux> er
<tidux> less
<tidux> or frotz
<tidux> or any other program that takes a file name as an argument
<ghast> is there a portable way of running a program from lisp?  [04:30]
<tidux> that's what I thought run-program was
<pjb> (ext:run-program "w3m" :arguments '("/home/pjb")) works perfectly well in clisp.
<tidux> huh
<pjb> ghast: AFAIK, there are some things in some libraries, but nothing really complete.
<tidux> I guess it's something to do with the program I'm launching it from, then  [04:31]
<ghast> ok.
<pjb> tidux: perhaps you're trying that in *inferior-lisp* or *slime-repl clisp* ?
<tidux> nope
<tidux> altho<tidux> although it is being launched from an interactive program I'm writing
<pjb> In my clisp in screen in xterm   it works nicely.
<tidux> so all the evidence points to a bug in my code  [04:32]
<tidux> thanks guys
<pjb> How interactive is it? Does it work in a terminal?
*** pjb (~t@81.202.16.46.dyn.user.ono.com) is now known as Guest88426  [04:52]
<tidux> ok, so it was definitely something in my code  [04:54]
<tidux> now I'm trying to have run-program read a variable name as the arguments
<tidux> (run-program "foo" :arguments '(*bar*))  [04:55]
<tidux> but that just says "*bar* no such file or directory"  [04:56]
<Bike> you're quoting the variable.
<Bike> (run-program "foo" :arguments (list *bar*))
<wbooze> huh why not :arguments '("bar") ?  [04:57]
<pjb> tidux: you didn't answer my question.
<tidux> which was that?
<pjb> How interactive was your program, whether it ran in a terminal?
<tidux> it does run in a terminal  [04:58]
<tidux> not in slime or anything, but it uses #!/usr/bin/clisp as the shebang interpreter
<pjb> You can also use xterm -e to launch a new xterm window in which to run w3m.
<pjb> ok.
<tidux> and I figured out it wasn't the leading / that mattered
<tidux> it was the way run-program handles variables in :arguments  [04:59]
<pjb> (if (ext:getenv "DISPLAY") (ext:run-program "xterm" :arguments (list "-e" "w3m" url))
      (ext:run-program "w3m" :arguments (list url)))
<tidux> like I said, if I feed it a straight URL or pathname it's fine  [05:00]
<pjb> ok
<tidux> oh wait, it's not
<tidux> wait, yes it is
<tidux> forgot my ' before the arguments list  [05:01]
<tidux> -_-
*** steffi_s_ (marioooh@nat/hackerschool.com/x-cxtdmbhhroqmqwxj) is now known as steffi_s  [05:02]
<tidux> I'm receiving a file name from user input, concatenating that to another string that
	provides the rest of the path, and passing that to a program
<tidux> the input and concatenation work exactly as expected
<tidux> it's just that when I use a variable for the contents of :arguments it gets weird  [05:03]
<pjb> tidux: you've been shown several example and told what not to do. Why does it still get weird?
											      [05:11]
<n00b6502> how much is lisp used these days  [06:15]
<pjb> 100% here.  [06:16]
<n00b6502> heh
<pjb> That said, to eat my atun can, I used a fork and a spoon instead of lisp.
<pjb> It's not perfect yet.
<pjb> Perhaps in a few years, I'll have a robot, and be able to program it to feed me atun in lisp.
											      [06:17]
<n00b6502> i keep thinking back to lisp on #haskell where the ability to define infix operators
	   leads to a lot of bewildering code  [06:18]
<pjb> You can use liskell.  [06:19]
<n00b6502> let me guess - is that a lisp-esque front end for haskell
<pjb> t
<n00b6502> or just a lisp with lazy eval
<pjb> nil
<pjb> There's cl-lazy for that.
<n00b6502> i think i need a text editor with color-coded braces though  [06:20]
<pjb> emacs
<n00b6502> i'm very surprised color coded nesting depth is not more popular
<pjb> With highlight-parentheses.el
<pjb> Because it's useless.
<pjb> We don't read or count parentheses.
<pjb> We use paredit, and it deals with them automatically.  [06:21]
<n00b6502> how does that work
<pjb> You have commands to edit sexp by sexp, instead of character by character.
<n00b6502> oh so like cursor movement is replaced with step in/step out etc
<pjb> Yes.  [06:22]
<n00b6502> how exactly does that work
<n00b6502> sounds intruiging  [06:23]
<pjb> Google for it: emacs paredit
<pjb> there are cheat sheets too.
<n00b6502> i guess emacs itself being  lisp based is a lispers editor of choice ?  [06:24]
<n00b6502> (when i say lisp-based, i mean its embedded ..)
<pjb> yes.  [06:26]
<pjb> It helps. It would be better if it was written in Common Lisp however.
<p_l> and it has a lot of warts
<pjb> There are emacsen written in Common Lisp, but it would be better if they had all the programs
      emacs has howver.
<p_l> in a way, it's a case of "how do I move all that stuff I use over to a new editor, after first
      writing a good editor"  [06:27]
<moore33> Write an emacs-lisp in Common Lisp, which kind of defeats the point.  [06:31]
<pavelpenev> I spent some time researching the topic last spring in preparation for GSoC(didn't get
	     accepted). I still can't decide if moving emacs to CL is futile or possible but not
	     worth all the effort.
<pjb> moore33: yes, to run the legacy code.
<moore33> Or learn to accept emacs lisp as a fine lisp, optimized for editing tasks, and run with
	  it.
<pavelpenev> moore33: the problem is that editing is only a small part of what emacs is for (only
	     half joking :)  [06:32]
<pjb> My opinion is that to be able to write good source CL tools, you need to write them in CL,
      because of reader macros, and macros.
<pjb> emacs lisp is a total failure when it has to deal with CL reader macros.  [06:33]
<moore33> pavelpenev: Heh, that says a lot about emacs lisp's capabilities.
<pjb> You try to write a nice command, such, eg. exporting symbols, and it breaks because
      forward-sexp can't parse #something.
<pjb> or emacs read.
<n00b6502> can emacs lisp be evolved one step at a time toward common-lisp
<pavelpenev> moore33: A friend of mine wrote a turn based strategy game in excel, that says a lot
	     about excel VBA :)  [06:34]
<n00b6502> e.g. each release removes or adds somehting and people update scripts appropriately
<pjb> Yes, one could add a reader macro system to emacs lisp.  But then, in your programs reader
      macros are written in Common Lisp!
<moore33> pavelpenev: Indeed.
<pjb> So what you can do is to use emacs-cl, which is a CL implementation written in emacs lisp, and
      write your commands in emacs-cl.
<n00b6502> whats more popular here cl or scheme  [06:35]
<Xach> peterhil: more about your friend, perhaps
<pjb> But soon you realize the only real solution is to have a good emacs written in CL>
<n00b6502> does scheme have lisp macros
<pjb> Hemlock is too many quirks, IMO.
<pjb> Not in r5rs.
<sykopomp> n00b6502: scheme is a different language than Lisp. Some schemes have a significantly
	   different macro system than common lisp does.
<pjb> emacs-cl is nice (and will probably be nicer on emacs-24 next year), but if you're writing a
      program with sbcl or ccl extensions, you won't be able to run it in emacs-cl to run your
      reader macros.  [06:36]
<zort-> I've started having this problem today where slime-eval-defun or slime-eval-last-expression
	just hang. Entering the form in the REPL works fine. Any ideas?  [06:37]
<pjb> Usually, reader macros give a facade to deep features of your program or your implementation,
      like FFI, implementation specific data structures, etc.
<pjb> So either you write two sets of reader macros, one for your editor, one for your program and
      do that for all your libraries (quicklisp and more), or you use a CL editor you can load in
      the implementation you're using.  [06:38]
<pavelpenev> the young idiot in me thinks it would be a good idea to just write a new editor and not
	     worry about backwards compatibility at all. Not even call it emacs, perhaps even *gasp*
	     try new ideas...  [06:41]
<hypnocat> you could call it vim..
<pavelpenev> ... and all the ideas would be tried in the 80's and forgotten :)  [06:42]
<n00b6502> an editor dedicated to lisp
<pjb> pavelpenev: well, the problem is that if what you want to write is just paredit, you can
      easily.  But if you also want to read your email, chat on irc, read usenet, run spreadsheets,
      play games, edit and compile C programs, etc, it is much less work to write an emacs lisp
      interpreter to run on your editor than to rewrite all those program.s
<n00b6502> with the paredit mode instrinsic
<pjb> http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/sedit/  [06:43]
<n00b6502> theres lots of programs for those other functions
<n00b6502> i think color coded braces are a nice solution since many people will need to jump
	   between languages  [06:44]
<pavelpenev> pjb: that would mean that the underlying system the editor is written in must make it
	     easy to write text editors and mail clients, and game of life implementations... IOW,
	     emacs the good parts.  [06:49]
<pjb> It is easy to do that in CL.
<pjb> What is not easy, is to have the time to do that in CL.  [06:50]
<pjb> It takes less time to write an emacs lisp implementation in CL than to rewrite all the emacs
      lisp programs in Common Lisp.
<pjb> It would be nicer if they were rewritten in CL, but we don't have enough CL programmers to do
      that.
<pjb> Now of course, if you were Gates or Shuttleworth you could finance the rewriting in CL.
											      [06:51]
<pavelpenev> rewriting emacs in CL step 1) profit  :)
<pavelpenev> this is lisp, we don't need an army of slaves to write software.  [06:53]
<moore33> All that to parse reader macros? :)
<madnificent> pavelpenev: i doubt many emacs users will want to drop all the libraries they
	      currently use
<pavelpenev> _of course_ the biggest challenge is social, we wouldn't want it to be too easy :)
											      [06:54]
<sykopomp> It would be nice to have a multithreaded emacs  [06:59]
<pjb> That said, perhaps rewriting would have more advantage than trying to run emacs lisp code.
*** cfy (~cfy@unaffiliated/chenfengyuan) is now known as ilisp  [07:15]
<Quadrescence> sykopomp, you know, we could work on CLIMACS  [07:23]
<olisp> I heard climacs was a failure.  Is there a paper describing it and its drawbacks?  [07:25]
*** ilisp (~cfy@unaffiliated/chenfengyuan) is now known as cfy  [07:28]
<p_l> the use of CLIM?  [07:29]
<pkhuong> same process for the editor and the edited code.  [07:30]
<olisp> This is an advantage, not a problem.  [07:34]
<pkhuong> olisp: nothing like crashing the editor when experimenting with unsafe or foreign code, or
	  hacking on the runtime environment or compiler. You're right, such highly-annoying events
	  make us much more cautious; clearly an advantage.  [07:37]
<olisp> Never happens for me :-)  [07:38]
<pkhuong> Happens to me all the time.  [07:42]
<maxm-> its actually pretty amazing that edebug manages to work much better then CL debuggers,
	without screwing emacs over in the process  [07:48]
<pjb> maxm-: I'm not surprised.  [07:49]
<sykopomp> Quadrescence: or I could just be lazy and keep using emacs until someone does the work
	   for me...  [07:50]
<pjb> That's what we're all doingâ€¦  [07:51]
<pjb> Any news from Tom?
* maxm- just discovered that there is weirdly written half of macsyma in emacs calc package  [07:52]
<Quadrescence> p_l, the use of CLIM is not a failure!
<maxm-> I'm writing a quick hack to track calories in org, so was pretty cool it can already parse
	stuff like "1/2 cups of whatever", and then do unit conversion and such
<pjb> maxm-: see what I meanâ€¦  [07:53]
* maxm- is tired of web 2.0 trackers.. Download that, install app this.. my hack will be "send
  yourself email with' "Food: 1/2 large apple, 2 slices pizza" and I'm done  [07:54]
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [08:11]
<ZombieChicken> Can someone give me a rough idea on how stable the Common Lisp standard is, as in
		how often is it modified from the original?  [08:24]
<pavelpenev> ZombieChicken: never
<p_l> ZombieChicken: no modifications. ever
<sykopomp> and there's no plans in the foreseeable future to make any official changes.
<ZombieChicken> Is there a site that gives a description of the diffrence between Scheme and CL?
<p_l> there is one addendum in practice, that is, the meta-object protocol, but it's smoothed out
      with closer-mop  [08:25]
<p_l> all the rest is covered by libs
<pavelpenev> ZombieChicken: the differences are so numerous it would be a pretty big site. One of
	     the previous scheme standards was 50 pages long, and the CL standard is 1000 pages.
											      [08:26]
<sykopomp> they're completely different languages with some common terminology, superficially
	   similar syntax, and sometimes completely different priorities.  [08:27]
<pavelpenev> scheme is probably closer to lua or javascript than to CL.
<ZombieChicken> ok, ty for all the info  [08:39]
<ZombieChicken> One more thing; is there a K&R-like (short and sweet) text for learning CL?  [08:41]
<pavelpenev> Practical Common Lisp is the usually recommended book. Available online here:
	     http://www.gigamonkeys.com/book/  [08:42]
<ZombieChicken> I don't think Practical Common Lisp qualifies as "short". I've worked through some
		of that, but it is a touch long winded for my taste, which is why I was asking if
		there was anything shorter  [08:43]
<pkhuong> ZombieChicken: nope.  [08:44]
<pavelpenev> CL is a much bigger language than C
<ZombieChicken> I'm sure of that, but one never knows until one ask
<n00b6502> is there a language like CL with infix notation... an infix notaitoin frontend  [08:46]
<n00b6502> or is the solution just better text editors (like paredit and lots of chromacoding etc)
<pavelpenev> n00b6502: dylan is such a language
<n00b6502> but presumably then youdont get the awesome macros  [08:47]
<pavelpenev> don't know about dylan, but various infix languages give you macros, but they suck big
	     time  [08:48]
<n00b6502> i think in principle i would prefer the purity of lisp syntax with assists to edit and
	   visualize it  [08:52]
<Bike> Have you tried SLIME?  [08:53]
<pavelpenev> n00b6502: I remembered scala had a macro library, so a quick google search brings me to
	     this example: http://scalamacros.org/documentation/gettingstarted.html
<pavelpenev> I would google for a perl 6 example, but I want to be able to sleep tonight  [08:54]
<n00b6502> what i have in my head is a lot of dynamic chromacoding and perhaps function arguments
	   poping up as you move the cursor  [08:55]
<kennyd> SLIME does that and a lot more  [09:02]
<kennyd> well, you get argument hints when you type the function name by default
<n00b6502> ok  [09:20]
<n00b6502> can lisp macros do something a bit like objective-c named parameters  [09:21]
<Bike> keyword arguments?  [09:22]
<n00b6502> what are those
<n00b6502> maybe they ae
<Bike> Why don't you read a book on Lisp, then you can get a solid base for your questions.  [09:23]
*** sambio_ (~cc@190.57.227.107) is now known as sambio  [09:43]
<pjb> ZombieChicken: Have a look at http://paste.lisp.org/display/122296 (intersection common-lisp
      emacs-lisp scheme)  [11:38]
<pjb> better than concentrate on differences, let's concentrate on what's common!
<pjb> ZombieChicken: there are several tutorials, some of them short (~100 pages). Check
      http://cliki.net/  [11:39]
<pjb> ZombieChicken: now, if you have still a few brain cells left, I'd love to hear what you think
      of the following:  given that the standard is more than 1000 pages, and describes the
      languages in a minimum number of words (there's no repeatition, reading an entry often
      requires knowing all the rest of the standard), how long do you think a tutorial that would
      cover the whole language would be?  [11:43]
<ZombieChicken> That would depend on how in-depth the tutorial was  [11:45]
<pjb> n00b6502: quick, what's (cadr '1+2*3-4) ?  [11:46]
<pjb> ZombieChicken: that would be at least 5000 pages.  [11:47]
<pjb> So if we give you a tutorial of a few pages, it won't cover the language at all.
<pjb> Programming is hard, let's go shopping.  [11:48]
<pjb> n00b6502: quick, what's (cadr '(- (+ 1 (* 2 3)) 4)) ?  [11:51]
<n00b6502> what is (cadr '1+2*3-4)   ... cadr is something to do with linklists, ' quotes a literal
<pjb> n00b6502: exactly.  If you have an infix syntax, you're screwed when you want to write macros.
											      [11:52]
<n00b6502> yeah i figured lisps' syntax made its macros powerful
<n00b6502> AST manipulation
<pjb> You could have a reader that reads 1+2*3-4 as (- (+ 1 (* 2 3)) 4), but you're still screwed.
<n00b6502> you'd have to have well defined points at which you switch  [11:53]
<pjb> It's not lisp syntax that makes it powerful, it's the homoiconicity of its syntax: data and
      code have the same syntax.
<n00b6502> one thing that interests me is the ability to create schema
<n00b6502> schemas
<n00b6502> in C/C++ one does all sorts of mess with 'x-macros', i can see the appeal of a very nice
	   macro system  [11:54]
<n00b6502> perhaps one could get the best  of both with operators being infix but a prefix form of
	   everything aswelll  [11:55]
<pjb> Not at all. That's my point. (cadr '1+2*3-4) is too hard.  [11:56]
<n00b6502> whenever i stray out of anything c-like the thing i really start to miss first is
	   object.member
<pjb> What's  (car 'object.member) ?
<n00b6502> infix operators restricted in their useability
<n00b6502> e.g. not visible to the macro system  [11:57]
<n00b6502> i've seen a retrofit to C which allows AST transformations but its highly nonstandard
<pjb> So you're breaking the macro system.  You can now get rid of it, congratulations.
<pjb> Now you can go on ##c to talk about what remains of your language.
<n00b6502> perhaps a text editor could parse the infix <-> prefix with the source strictly being
	   prefix  [11:58]
<pjb> n00b6502: you have to realize also that over the 978 symbols exported by CL, only 25 are
      special operators.  The rest of the language are 88 macros.  [12:00]
<pjb> the 661 functions and the 88 macros can be implemented with those special operators.  [12:01]
<n00b6502> ok i get it, if your'e trying to say "lisp macros beat infix"
<n00b6502> "as a general tool"  [12:02]
<pjb> Yes, lisp macros beat everything in programming.
<n00b6502> hah even haskell ?
<pjb> Sure.
<pjb> Haskell was written in Lisp originally.
<pjb> Thanks to macro, you can add to lisp any extension you want.  That's why lisp is the ultimate
      programming language, and all the others are just DSLs, often written originally in Lisp.
											      [12:03]
<n00b6502> funny how its got this powerful feature but most people react very negatively to prefix
											      [12:06]
<pjb> Are you reacting negatively to prefix notation?  [12:07]
<n00b6502> i'm reacting posatively to the idea of being able to manipulate the AST, i'lll say that
<n00b6502> i guess there are probalby ways of using macros to make the object acess read ok
<n00b6502> i found i could handle writing maths in prefix ok.  [12:09]
<jfe> hi all  [12:10]
<pjb> Yes you don't write xâˆ«dx, you write âˆ«xdx
<n00b6502> the main reason "maths in prefix" is ok is i ususally use a lot of helpers, like "lerp",
	   "invlerp" etc  [12:11]
<n00b6502> i suppose you could make a macro to sum products  (mulsum (a b) (c d) (e f)) =
	   a*b+c*d+e*f,( does that need quotes in there?)  [12:13]
<jfe> i'm reading paul graham's "ANSI Common Lisp", and on p. 40 he says that conses can be
      interpreted as binary trees, "with the car representing the right subtree and the cdr the
      left." but if that's true, then where does the value for each node go?
<n00b6502> values are leaves  [12:14]
<n00b6502> ?
<n00b6502> values are only on leaves, perhaps
<pjb> why should node have labels?  [12:15]
<pjb> Otherwise, the magic of cons cells, is that you can use them to build "cells" with more slots.
<pjb> With two cons cells, you can make a binary tree node with a label: (cons label (cons left
      right))  [12:16]
<pjb> With three cons cells, you can make a ternary tree node with a label: (cons label (cons left
      (cons mid right)))
<n00b6502> scheme doesn't have the lisp macro system then?  [12:17]
<pjb> r5rs specifies a different macro system.  You can easily implement the CL macro system.  A lot
      of scheme implementations have both.
<specbot> Sorry, I couldn't find anything for specifies a different macro system.  You can easily
	  implement the CL macro system.  A lot of scheme implementations have both..
<jfe> pjb: the list he uses as an example is this: (a (b c) d)
<pjb> jfe: are we talking of trees or of lists?  [12:18]
<pjb> jfe: that said, instead of cons cells, you can also use lists to build tree nodes.
<jfe> pjb: we're talking about interpreting that list as a binary tree; i don't quite see it.
											      [12:19]
<pjb> jfe: ok, so you have to decide how you interpret the contents of the list.  [12:20]
<pjb> For a binary tree with labels, you can represent each node as a list (label left-child
      right-child)
<n00b6502> is there a predefined macro to set multiple slots on an object e.g. (set-slots  object
	   (slot1 newvalue1) (slot2 newvalue2)...)
<pjb> Then the lists should have three elements.
<pjb> n00b6502: setf
<n00b6502> thats neat  [12:21]
<pjb> as in: (setf (slot-value object 'slot1) value1 (slot-value object 'slot2) value2)
<n00b6502> ok i've got in my head definitng another shortcut
<Quadrescence> you can do with-slots, and setf those
<pjb> there's with-slots too.
<n00b6502> (with-slots object (setf 'slot1 value1 'slot2 value2 ) ) perhaps  [12:22]
<Bike> I think you should learn enough CL to program comfortably, and then think about what
       extensions you want for your own code.  [12:24]
<pjb> jfe: have a look at http://groups.google.com/group/comp.lang.lisp/msg/0c66e597e08be90d
<pjb> clhs with-slots
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/m_w_slts.htm
<pjb> jfe: now, if (a (b c) d) is an example of the tree definition of page 40. that you gave above,
      then the conses are: (a  . ((b  . (c  . ())) . (d  . ()))) ; you should be able to draw the
      binary tree (with labels attached only to the leaves) easily.  [12:26]
<n00b6502> is there a tool along the lines of 'hoogle', a lisp search.. e..g. write a peice of lisp
	   code and it tells you what the name is  [12:35]
<n00b6502> checks for identical peice of AST
<pjb> Yes. It's called google.
<pjb> :-)
<n00b6502> google doesn't know about lisp AST surely :)  [12:36]
<pjb> There's so many different ways to write the same function!
<n00b6502> lets say i write my macro (set=slots...)  ... i submit the implementation -  and it tells
	   me if it already exists
<pjb> n00b6502: for example: http://www.informatimago.com/develop/lisp/l99/p06.lisp  [12:37]
<n00b6502> sure its not going to be a magic bullet,but i figured it might be a virtue of evrything
	   being in AST form that its easier to do here
<pjb> there are so many ways to write the same macro!!!
<pjb> n00b6502: but you can have fun trying to write such a tool.
<n00b6502> 'duplicate function detector' i guess
<n00b6502> it is usually called  [12:38]
<pjb> On the other hand, if you have a look at the libraries, the functions doing the same thing,
      while being written often quite differently, are usually named the same.  [12:39]
<n00b6502> i suppose such a database keeping  a list of synonymous function implementations might be
	   nice
<pjb> It's a free internet.  [12:40]
*** VieiraN_ (~VieiraN@201-95-165-77.dsl.telesp.net.br) is now known as VieiraN
<n00b6502> i think i'd have to write the 'set-slots' thing to do anthing  [12:41]
<n00b6502> and probably a load more  [12:42]
<pjb> why not just use with-slots?
<n00b6502> C++:  obj.x=10; obj.y=20;       my idea:  (set-slots obj (x 10) (y 20))    . what does
	   that look like using "with-slots"  [12:43]
<pjb> (with-slots (x y) obj (setf x 10 y 20)) !
<n00b6502> even if i was  only going to use it once i think i'd write my macro  [12:44]
<n00b6502> because its grouped nicer
<n00b6502> is there such a thing as an n-ary 'set-slot' 'get-slot'  e.g.   c++ obj.part1.x=10
	   (set-slot (obj part1 x) 10) ... perhaps the brackets in the 'my idea' could acheive that.
	   (set-slots obj (part1 x 10))  [12:51]
<n00b6502> let me find a repl.  [12:52]
<pjb> n00b6502: http://groups.google.com/group/comp.lang.lisp/msg/190d771c0e033a1c  [12:53]
<pjb> http://www.informatimago.com/articles/usenet.html
<n00b6502> i'm guessing someone somehwere has written every macro i have in mind :)
<pjb> you have 50 years of learning to catch up.  [12:54]
<n00b6502> lisp from c++  [12:55]
<Quadrescence> pjb, using EVAL seems like a desperate move :(
<Bike> pjb: hm, might that be better with defsetf or something, so you can avoid eval?  I'm not sure
       how you'd do it, but..
<pjb> Yes, but for structures you cannot do otherwise, conformingly.
<pjb> there's no setf-expander for structure slots (not necessarily at least).  [12:56]
<pjb> Bike: now you're right, using define-setf-expander for -> would let use define it for
      structure slots without using eval.  [13:02]
<n00b6502> heh every language does one thing amazingly well, and one thing amazingly badly.  [13:06]
<pjb> Bike: there's a problem with defsetf or define-setf-expander for ->: the object type could
      change at run-time, so the operation to use to set it cannot be decided at expansion time.
											      [13:13]
<Vivitron`> n00b6502: and you are likely to change your mind on what those things are as you
	    progress from a beginner to an advanced user  [13:14]
<Bike> pjb: oh, I hadn't thought of that... maybe if n00b wants to keep the usual use of dot
       semantics, you'd only need it on standard instances, though.  [13:15]
<n00b6502> i can see with macros you could certainly wwork without dot semanics. it is just the one
	   thing that jumps out first leaving c-like-land  [13:17]
<n00b6502> i can see the potential to set multiple things at once is interesting :)  [13:18]
<pjb> n00b6502: setf doesn't set multiple things at once.  Try psetf for that.  [13:19]
<n00b6502> i supose with-slots is more like writing 'member functions' in c++; perhaps there is a
	   'with-all-slots' or even default behaviour if givn an empty lotlist  [13:21]
<pjb> n00b6502: actually, with operators are bad.  There are blogs about how bad it is!  [13:22]
<n00b6502> oh
<n00b6502> can you sumarise why?
<pjb> with-slots is good because you can use a different variable name for each slot.  [13:23]
<n00b6502> and would my 'set-slots' be bad for the same reason
<pjb> (with-slots ((x1 x) (y1 y)) pt1 (with-slots ((x2 x) (y2 y)) pt2 (make-pt (+ x1 x2) (+ y1
      y2))))  [13:24]
<pjb> but the with of Pascal or some other programming languages don't allow this renaming so
      they're useless.
<n00b6502> usually my C/C++ head has me splitting code into functions dealing with 'source' and
	   'dest' objects  [13:25]
<pjb> set-slots would be uterly confusing. What would (set-slots obj (x (+ 1 x)))  mean?
<phadthai> I remember using something like a (with-fast-accessors (:prefix obj) (setf prefix-foo
	   bar)) for inlined access to internal C structures
<pjb> This is not ##c!
<pjb> n00b6502: go learn CL or stay in ##c!  [13:26]
<n00b6502> heh. every channel has its language zealots convinced theirs is the only way
<n00b6502> macros do create potential for conflict as different programmers can create such
	   different styles  [13:28]
<n00b6502> but personally i would not enjoy coding without them
<pjb> No, there's no conflict, because macros are lexically scoped.
<pjb> n00b6502: but you still haven't said what would (set-slots obj (x (+ 1 x)))  mean?  [13:29]
<n00b6502> 'set slots woould be utterly confusing...' there's conflict between you and me
	   already. My first instinct would be to write that
<pjb> n00b6502: what would (set-slots obj (x (+ 1 x)))  mean?
<pjb> If you cannot answer that simple question, it's proof your macro is uterly botched.
<n00b6502> if x was a variable in the outer scope, it would use that i think? (if thats how they
	   work)
<pjb> And you don't find that confusing?  [13:30]
<n00b6502> { x=4;  obj.x=x+1;}
<n00b6502> well, given that i might have variable and member names the same ....
<Bike> n00b6502: well there's sort of a problem if you just fix CL to fit your preconceptions
       instead of coding in CL.  you may as well code in C, see
<n00b6502> the confusion would come from naming variables not the macro
<n00b6502> i would not assume that any number of years had produced every macro that makes sense
											      [13:31]
<n00b6502> for every single sitution
* didi remembers "compiling" C-to-CL programs by hand
<pjb> n00b6502: the point here is that macros let you design languages: Lisp makes you a programming
      language designer, not a mere coder.  So you must design your macros taking into account this
      kind of consideration.
<pjb> If your macro can be used in confusing ways, perhaps its design is not so good and you should
      think again.  [13:32]
<n00b6502> for me set-slots would make sense because it is instinctively what i thought first
<n00b6502> and I am not unique
<n00b6502> i am not a snowflake
<n00b6502> it'll make sense to a few others i'm sure
<Bike> well, try it out and see how it goes.
<phadthai> http://fumaga.com/i/the-first-snowflake-of-the-season.jpg  [13:33]
<pjb> Vernon, I'm falling! Oh shit I'm falling! :-)  [13:34]
<pjb> That's why I read xkcd.  [13:35]
<pjb> phadthai: clean your brain: http://what-if.xkcd.com/6/
<phadthai> I read that already :)  [13:36]
<n00b6502> set-slots above, i think if using 2 objects one would create a load of temporaries
	   reading from one thing, then write to another with ste-slots  [13:38]
<pjb> With-slots doesn't work using temporaries  [13:39]
<pjb> On the other hand, you may prefer with-accessors.
<pjb> (which uses even less temporaries).  [13:40]
<n00b6502> minimizing the number of temporaries is something i'm in 2 minds about, on the one hand
	   its like self-commenting to name parts of an expression, on the other, its irritating to
	   have to name thigns that dont warrant naming  [13:41]
<n00b6502> (e.g. like in C having to name small functions & intermediate structs that would be
	   better anonymous)
<moore33> xach: hey there  [14:53]
<n00b6502> does lisp have a concept of 'const' or is that done with pure functions  [14:58]
<n00b6502> (const object pointers as 'immutable sources' in c++)
<n00b6502> (for making inputs/outputs clear)
<Quadrescence> There is an idea of constant bindings to certain values in Lisp  [15:02]
<didi> clhs defconstant  [15:09]
<specbot> http://www.lispworks.com/reference/HyperSpec/Body/m_defcon.htm
<didi> I find it a little weird.  [15:10]
<n00b6502> not really constants.. more like 'read only arguments to a function'  [15:11]
<n00b6502> pure functions are probably a better solution in newer languages i suppose
<didi> Just don't setf stuff?  [15:12]
<n00b6502> i suppose an analyzer can generate documentation
<phadthai> structures and clos objects may have read-only slots too  [15:20]
<n00b6502> ah i've seen that
<n00b6502> thats quite neat
<phadthai> as for read-only function arguments you might need a custom defun macro or
	   implementation-specific help  [15:22]
<phadthai> if you want to enforce that
<n00b6502> clojure is a pure-functional lisp variant, right?  [15:23]
<n00b6502> i suppose it you're not writing separete header & implemenattion as per C++ there's less
	   use for it
<n00b6502> trying to find a language other than C++ to learn...  [15:28]
<didi> n00b6502: Lisp is awesome.  [15:29]
<n00b6502> just discovered 'with slots' doesn't require you to list everything, thats nice  [15:30]
<n00b6502> (with-slots () object (......))
<n00b6502> so (with-slots () object (setf ......)) nearly does what i wanted with 'set-slots'
											      [15:33]
<n00b6502> does lisp have anything like tuples  [15:34]
<didi> Immutable sequence?  [15:35]
<n00b6502> described as 'anonymous structs' for C++ heaad  [15:36]
* didi doesn't know C++
<n00b6502> described as 'anonymous structs' for C heaad
<didi> Never heard of it.
<n00b6502> i think its an immutable sequence, 'ad-hoc'..
<rwiker> multiple-value-bind & friends may give you what you're looking for
<n00b6502> just playing around in clisp repl .. seeing what it looks like to setup 3d vector maths
											      [15:38]
<rwiker> in that case, you should look at defclass adn defstruct (in that order :-)  [15:41]
<n00b6502> has anyone here gone from a c like langauge to lisp and genuinely liked it  [15:43]
<didi> Absolutely.  [15:44]
<n00b6502> one thing that appeals to me about lisp is you could easily use a subset as a dsl with a
	   custom interpreter in a c++ program..
<didi> n00b6502: I think you might be too hooked up to C++.  [15:45]
<n00b6502> i'm not going to lose c++
<n00b6502> 15+ years, and 23 years asm->c->c++ ... its staying in my head
<didi> You'll have to learn new ways.  [15:46]
<n00b6502> is there a way to declare a partially applyable (curryable?) function like in haskell ,or
	   is it prefered to always write (lambdaa..)  [15:47]
<Quadrescence> n00b6502, why not define CURRY (or use Alexandria's CURRY)?  [15:49]
<rwiker> Or just use a lambda (or defun) wrapped inside a let.
<Quadrescence> rwiker, how is that currying? That sounds more like creating a closure.  [15:50]
<rwiker> right? but n00b6502 also mentioned partial application  [15:51]
<n00b6502> given a (defstruct point x y z)...  [15:55]
<n00b6502> ..is there a  better way to write (defun dot (a b) (with-slots ((ax x)(ay y)(az z)) a
	   (with-slots ((bx x)(by y)(bz z)) b (+(* ax bx)(* ay by)(* az bz)))))  [15:56]
<n00b6502> i guess i can avoid one set of labelling; is there something like a multiply-sum
	   operator?  (mulsum a b c d..) =  a*b+c*d+...  [15:57]
<Quadrescence> n00b6502, you might as well just call the accessors directly
<n00b6502> ah struct makes point-x point-y point-z i see  [15:58]
<Quadrescence> n00b6502, as you might find later, that can be customized, the names of the accessors
											      [15:59]
<n00b6502> perhaps (defun dot (a b) (with-slots () a (+(* x (point-x b)).....)))))
<Quadrescence> n00b6502, http://paste.lisp.org/display/131214  [16:00]
<n00b6502> do the acessors neeed the prefix to avoid namespace clash; and perhaps with classes it
	   uses polymomrphism, so  doesn't suffer that
<Quadrescence> you can specify the prefix. I've specified no prefix in that example.  [16:01]
<n00b6502> ok
<Quadrescence> n00b6502, however, I suggest that you not focus on trying to minimize the amount you
	       type.
<Quadrescence> I also suggest you don't specify a :CONC-NAME. I don't see any reason to.  [16:02]
<n00b6502> i like it when you can both use verbose names and type a as with the 'with-slots'
<n00b6502> bad example  [16:03]
<Ralith> n00b6502: it looks like you're trying to write a vector math library!  [16:04]
<n00b6502> i'm liking 'with-slots' so far for clarifying the end
<Ralith> would you like some sb-cga with that?
<n00b6502> sb-cga = ?
<Ralith> a better linear math library.
<n00b6502> i figured trying to write something i'm very familiar with in C++ would be a good place
	   to start..  [16:05]
<Ralith> it sounds like you're not very familiar with the actual math behind this
<n00b6502> how have you figured that out  [16:06]
<Ralith> oh, scratch that, sorry
<n00b6502> done car-physics and 3d engines in c++, i'm quite familiar with 3d math
<Ralith> kk
<Ralith> anyway, if it's just an exercise, cool, but be aware that you are reinventing a very well
	 optimized wheel
<n00b6502> sure.  [16:07]
<rwiker> if it's for learning, you might as well start with defclass instead of defstruct
<Ralith> also, with-slots on a struct isn't portable
<n00b6502> instantly i guess that defclass stores more RTTI than defstruct, but is that correct ?
<Ralith> n00b6502: CL does not specify anything about that.  [16:08]
<n00b6502> ouch ok. whats the issue with "with-slots"
<rwiker> defstruct is basically a one-shot, which cannot be redefined without restarting your lisp
	 environment
<Ralith> with-slots is specified as operating on classes.
<Ralith> some implementations extend it to operate on structs.
<Ralith> some don't.
<n00b6502> heh ok
<n00b6502> i hear of 'multiple dispatch' in lisp, that sounds cool  [16:09]
<Ralith> it is!
<Ralith> wouldn't use it in a linear math lib, personally.
<n00b6502> absolutely i wouldn't :)
<n00b6502> random q... is there a lisp with an LLVM backend  [16:11]
<Ralith> not yet (though you could do ECL -> C -> LLVM if you really wanted)  [16:12]
<n00b6502> ah if you can go lisp->C i'm just as content
<rwiker> any reason that you want to go via C?
<n00b6502> is there a lisp for iphone  [16:13]
<rwiker> sorry, that was not well stated.
<Quadrescence> rwiker, clearly he comes from a C (and/or) C++ background...
<Quadrescence> So I'm sure he's bound to miss it in the short-term. :)
<n00b6502> the use of lisp as "goal" by naughty-dog on the ps2 had always fascinated me  [16:14]
<n00b6502> at this point i'm tempted to ask, could a macro be setup to write the '(with-slots  (ax
	   x) ... (with-slots (ay y..)  [16:16]
<n00b6502> to streamline writing lots of binary-operators for 2 points
<Quadrescence> n00b6502, I sometimes write a corresponding DESTRUCTURE-<struct> macro
<n00b6502> i think macros are what i'm here for.  [16:19]
<Quadrescence> n00b6502, http://paste.lisp.org/display/131214#1  [16:21]
<n00b6502> ok neat
<n00b6502> destsructure as in "extract variables from structure.."  [16:22]
<Quadrescence> sure, i take the name from DESTRUCTURING-BIND  [16:23]
<n00b6502> the pattern matching in haskell is pretty interesting
<Quadrescence> n00b6502, pattern matching, section 2.4 of
	       http://www.defmacro.org/papers/cl-monad.pdf  [16:24]
<phadthai> n00b6502: also look at with-accessors btw, on some implementations that's optimized
	   better than with-slots
<n00b6502> where they'd say, if using tuples for x,y,z dot (ax,ay,az) (bx,by,bz) = ax*bx+ay*by+az*bz
<n00b6502> i'm having a hard time picking a language to put serious time into other than c++
	   ... many options  [16:25]
<phadthai> n00b6502: I come from a C background myself and am using ECL, I like its integration with
	   C and I like lisp to experiment with fast mostly-interactive development
<Quadrescence> n00b6502, Most of what you've been talking about sounds like writing short, concise
	       code. Little typing. If you want that, choose a language like Haskell or APL.
<n00b6502> ok that sounds like it could be right up my street
<n00b6502> what seems appealing about lisp is,  [16:26]
<n00b6502> the things one does with x-macros in C .. trying to fudge schemas - i gather lisp can do
	   'properly'
<Quadrescence> Not sure what you mean.  [16:27]
<n00b6502> e.g. how much is required to declare a structure , then write an xml writer for it
											      [16:28]
<n00b6502> c#  is very concise at doing that due to reflection
<Quadrescence> That's shorter in Lisp than in C, and probably even shorter in Haskell than in Lisp.
<phadthai> when I said fast interactive development, here's an example: type one or a few functions
	   in the editor, using C-c on them to compile them in the running image, test them at the
	   REPL interactively, without caring much about speed other than chosing adequate enough
	   algorithms or data structures  [16:32]
<phadthai> if further testing shows something is suboptimal and it's a problem, profiling will show
	   what needs to be improved, then one can specialize more the critical code, add
	   declarations, etc
<n00b6502> i miss the REPL from basic childhood  [16:33]
<n00b6502> heh
<n00b6502> repl's are awesome  [16:34]
<Quadrescence> Haskell has huge advantages over Lisp in some respects. Aside from the obvious type
	       safety, Haskell is much more expressive with data types than Lisp. Same with other
	       languages like Standard ML. Working with and manipulating some data structures in
	       Lisp is either slow (overuse of stuff like dynamic dispatch) or hairy (writing
	       annoying things like DESTRUCTURE-POINT).
<phadthai> and the language is also powerful enough to easily "plug fast hacks" too, i.e. consider
	   dynamic scoped variables vs function arguments, the difference between defvar and
	   defparameter, between defstruct (where redefinition is undefined) and clos (where one an
	   even provide migration code for existing instances)  [16:35]
<pjb> with-slots doesn't work on structures.  [16:41]
<Quadrescence> pjb, it was discussed already :)
<pjb> For structures, you must use with-accessors.
<pjb> Not soon enough.  [16:42]
<phadthai> so basically I find that lisp can be used as a scripting language but is also more
	   because of compilation, macros, declarations...  [16:45]
<pjb> n00b6502: have a look at cling.
<pjb> Quadrescence: last time I looked at it, Haskell didn't have a repl. (where you could define
      functions).
<Quadrescence> pjb, it does, you just have to say:   let f x = ...  [16:46]
<Quadrescence> Prelude> let sq x = x*x  \  sq :: Num a => a -> a  \  (0.00 secs, 0 bytes)  [16:47]
<Quadrescence> \ = newline
<phadthai> compiling haskell is also very slow in my experience (too slow for interactive use), but
	   I guess that interpreters could be used along with a repl (I admit I don't have much
	   experience with it though, when I looked at it years back, it didn't seem general purpose
	   enough to me)  [16:48]
<pjb> ok, this time it works.  But last time I tried it it didn't work.
<pjb> How do you exit from ghci?  [16:49]
<Mon_Ouie> By hitting ^D
<Quadrescence> or   :quit  [16:50]
<pjb> Doesn't work in M-x shell
<pjb> Ok, :quit works.
<Mon_Ouie> C-q C-d RET :p
<pjb> Mon_Ouie: Yes, I tried that, and that's what didn't work.  [16:57]
<rwiker> Another way of macrofying the 3d-point class: http://paste.lisp.org/display/131214#2
											      [17:02]
*** superflit_ (~superflit@63-228-84-4.hlrn.qwest.net) is now known as superflit  [17:03]
<n00b6502> neat
<pjb> You could have used with-accessors in with-points.  [17:05]
<pjb> or with-slots, since it's a defclass.
<n00b6502> i wondered if you could combine the defun and 'with-points' .. like a
	   def-point-binary-function
<pjb> and name the symbols a.x b.x instead of a-x b-x
<pjb> n00b6502: can you design an algorithm for that?  [17:06]
<pjb> If you can design an algorithm then you can.
<Quadrescence> I do something vaguely similar: DEFINE-POINTWISE-OPERATION:
	       https://bitbucket.org/tarballs_are_good/lisp-random/src/647c009921a9/fft.lisp#cl-14
											      [17:07]
<Quadrescence> (text only:
	       https://bitbucket.org/tarballs_are_good/lisp-random/raw/647c009921a9/fft.lisp )
<Quadrescence> (note, that code isnt very good. e.g, there's no good reason to have CATVEC)  [17:10]
<phadthai> if performance mattered a lot, it also could be a structure with a constructor that
	   doesn't use keyword arguments, which would be fine as long if your point object is
	   unlikely to change
<n00b6502> sure, very unlikely
<rwiker> you could also use defstruct with (:type vector)  [17:11]
<phadthai> the constructor function could process its arguments faster if it's used a lot, and since
	   redefining structures has undefined consequences, it allows compilers to use more static
	   optimization methods
* Quadrescence really wishes SLIME highlighted macros like paste.lisp.org does...  [17:13]
<pjb> paste.lisp.org is written in CL; slime is written in emacs lisp.
<Quadrescence> indeed
<Quadrescence> pjb, good CLIMACS propaganda material. Thanks!  [17:14]
<Guthur> how exactly is paste.lisp.org highlighting macros differently? I see no difference.  [17:16]
<Quadrescence> Guthur, (purple) italics?
<Guthur> Quadrescence: if it's a with-... slime does that  [17:17]
<Guthur> does no different, case in point destructure-point is not highlighted
<Guthur> because it is not a with-...
<Quadrescence> I guess maybe paste.lisp.org isn't really highlighting macros. I see above it's not
	       highlighting my DESTRUCTURE-POINT  [17:18]
<Quadrescence> yeah
<Quadrescence> My mistake.
<Quadrescence> (it would be nice if it could!)
<rwiker> there appears to be a bug in the lisppaste implementation (look for b-x)
<Guthur> yep it would
<Guthur> but so many of my macros tend to be with-... or define-...
<Guthur> which both get highlighted
<n00b6502> map behaves like 'zip' potentially i see  [17:24]
<pjb> n00b6502: map basically behaves like ALL the functions.  [17:26]
<pjb> potentially.
*** [SLB]` (~slabua@unaffiliated/slabua) is now known as [SLB]  [17:27]
<Xach> moore33: hi  [17:33]
<Guthur`> Xach: is there some way to verify an all-dists update  [18:09]
<Guthur`> It timed out during and update, slow internet, and then why I tried (ql:update-all-dists)
	  again it says I already have the latest version  [18:10]
<Guthur`> but I am left less than certain that update was indeed successful
<Xach> Guthur`: the update just tries to fetch new versions of what you already have, but if it
       fails, it will just fetch them on demand.  [18:11]
<Guthur`> ok, I suppose all should be well then.  [18:12]
<Guthur`> damn slow internet, quite frustrating  [18:13]
*** yCrazyEdd (~Botrydium@wrongplanet/CrazyEddy) is now known as CrazyEddy  [18:28]
*** cfy` (~cfy@125.123.43.194) is now known as cfy  [19:37]
*** jjkola_ (~androirc@212-226-67-80-nat.elisa-mobile.fi) is now known as jjkola  [19:47]
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [20:03]
*** [SLB]` (~slabua@unaffiliated/slabua) is now known as [SLB]  [20:10]
*** [SLB] (~slabua@unaffiliated/slabua) is now known as [SLB]`  [20:59]

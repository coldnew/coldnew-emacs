#+TITLE: Interactive Commands
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+DESCRIPTION: Some my personal's interactive commands
#+LANGUAGE: en
#+STARTUP: overview indent align
#+BABEL: :cache yes
#+OPTIONS: ^:nil num:nil tags:nil
#+SETUPFILE: ../assets/readtheorg.setup

In emacs, we can use =M-x= to execute interactive commands, I implement some of them to make my emacs more easy to use.

* Buffers                                                            :buffer:

** Kill all buffers except *scratch* buffer

Sometimes I just want to kill all buffers, this command will kill all
of them and make =*scratch*= buffer alone.

#+BEGIN_SRC emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+END_SRC

** Make emacs can always save buffers (even if file is not modified)

The default command *save-buffer* will not really save file when it
untouched, use this command can let me force save file even if file is
not modified.

#+BEGIN_SRC emacs-lisp
  (defun my/save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+END_SRC

** Abort minibuffer recursive edit

#+BEGIN_SRC emacs-lisp
  (defun minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))
#+END_SRC

** Make buffer untabify

#+BEGIN_SRC emacs-lisp
  (defun untabify-buffer ()
    (interactive)
    (save-excursion
      (untabify (point-min) (point-max))))
#+END_SRC

** Indent whole buffer

#+BEGIN_SRC emacs-lisp
  (defun indent-whole-buffer ()
    "Indent whole buffer."
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max))))
#+END_SRC

** Remove buffers trailing whitespace and untabify

#+BEGIN_SRC emacs-lisp
  (defun cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (save-excursion
      (delete-trailing-whitespace)
      (indent-region (point-min) (point-max))
      (untabify (point-min) (point-max))))
#+END_SRC

** Replace the preceding sexp with its value

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
#+END_SRC

** Quick folding source block

#+BEGIN_SRC emacs-lisp
  (defun quick-folding-source ()
    "Use emacs buildin easy to folding code."
    (interactive)
    (set-selective-display
     (if selective-display nil 1)))
#+END_SRC

** Narrowing to code more wisely

ref: http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+BEGIN_SRC emacs-lisp
  (defun my/narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun,
  whichever applies first. Narrowing to org-src-block actually
  calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is
  already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ;; org-mode
          ((and (boundp 'org-src-mode) org-src-mode (not p))
           (org-edit-src-exit))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if you
           ;; don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ;; latex-mode
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))
#+END_SRC

* Edit (Insert/Remove)                                                 :edit:

** Insert U200B char

=<U200B>= character is a =zero width space character= which is nice to
use under org-mode.

For more info, please see: [[https://lists.gnu.org/archive/html/emacs-orgmode/2012-09/msg00155.html][suggestion for org-emphasis-regexp-components: *U*nited *N*ations]]

#+BEGIN_SRC emacs-lisp
  (defun insert-U200B-char ()
    "Insert <U200B> char, this character is nice use in org-mode."
    (interactive)
    (insert "\ufeff"))
#+END_SRC

** Insert empty line after current line

#+BEGIN_SRC emacs-lisp
  (defun insert-empty-line ()
    "Insert an empty line after current line and position cursor on newline."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1))
#+END_SRC

** Insert lorem ipsum

#+BEGIN_SRC emacs-lisp
  (defun insert-lorem ()
    "Insert a lorem ipsum."
    (interactive)
    (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
            "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
            "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
            "aliquip ex ea commodo consequat. Duis aute irure dolor in "
            "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
            "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
            "culpa qui officia deserunt mollit anim id est laborum."))
#+END_SRC

** Delete word

#+BEGIN_SRC emacs-lisp
  (defun delete-word (arg)
    "Delete characters forward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-region (point) (progn (forward-word arg) (point))))
#+END_SRC

** Backward delete word

#+BEGIN_SRC emacs-lisp
  (defun backward-delete-word (arg)
    "Delete characters backward until encountering the end of a word.
  With argument, do this that many times."
    (interactive "p")
    (delete-word (- arg)))
#+END_SRC

** Set mark or expand region

#+BEGIN_SRC emacs-lisp
  (defun set-mark-mode/rectangle-mark-mode ()
    "toggle between set-mark-command or rectangle-mark-mode"
    (interactive)
    (if (not mark-active)
       (call-interactively 'set-mark-command)
      (call-interactively 'rectangle-mark-mode)))
#+END_SRC

** Indent region/buffer and cleanup

#+BEGIN_SRC emacs-lisp
  (defun indent-region-or-buffer-and-cleanup ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (cl-flet ((format-fn (BEG END) (indent-region BEG END) (untabify BEG END)))
      (save-excursion
        (if (region-active-p)
            (progn
              (delete-trailing-whitespace (region-beginning) (region-end))
              (format-fn (region-beginning) (region-end))
              (message "Indented selected region and clear whitespace and untabify."))
          (progn
            (delete-trailing-whitespace)
            (format-fn (point-min) (point-max))
            (message "Indented whole buffer and clear whitespace and untabify."))))))
#+END_SRC

** Copy and comments

#+BEGIN_SRC emacs-lisp
  (defun my/copy-and-comment ()
    "Copy region and comment it."
    (interactive)
    (kill-ring-save (region-beginning) (region-end))
    (comment-dwim nil))
#+END_SRC

* File Handle                                                          :file:

** Reopen file as root

#+BEGIN_SRC emacs-lisp
  (defun file-reopen-as-root ()
    (interactive)
    (when buffer-file-name
      (find-alternate-file
       (concat "/sudo:root@localhost:"
               buffer-file-name))))
#+END_SRC

** Delete current buffer file

#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC

** Rename current Buffer and file

#+BEGIN_SRC emacs-lisp
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
#+END_SRC

** Add executable attribute to file

Actually this command is the same as =chmod +x= but it doesn't use any shell
command, it use emacs's logior function to change file attribute.

I only make =owener= can has executable permission, not change it for gourp or
others user.

#+BEGIN_SRC emacs-lisp
  (defun set-file-executable()
    "Add executable permissions on current file."
    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
#+END_SRC

** Clone current file to new one

#+BEGIN_SRC emacs-lisp
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+END_SRC

** Show current buffer-file information

#+BEGIN_SRC emacs-lisp
  (defun my/file-info ()
    "Show current buffer information."
    (interactive)
    (if (buffer-file-name (current-buffer))
        (progn
          (let* ((file-name (buffer-file-name (current-buffer)))
                 (f-attr (file-attributes file-name))
                 (f-size (nth 7 f-attr))  ; ファイルサイズ
                 (f-mode (nth 8 f-attr))  ; ファイル属性
                 (mes1 (format "file path: %s\n" file-name))
                 (mes2 (format "file size: %s byte\n" f-size))
                 (mes3 (format "file type: %s" f-mode))
                 (mess (concat mes1 mes2 mes3)))
            (message "%s" mess)))
      nil))
#+END_SRC

* Debug                                                               :debug:

** Eval emacs buffer until error

A really nice command help me to find error on elisp buffer.

#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."
    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

** Display face found at the current point

#+BEGIN_SRC emacs-lisp
  (defun what-face (pos)
    "Display face found at the current point."
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Reload emacs init config

#+BEGIN_SRC emacs-lisp
  (defun my/reload-init ()
    "Reload init.el file"
    (interactive)
    (load-file user-init-file))
#+END_SRC

* Window                                                             :window:

** Switch to other window or split it

If other window does not exist, split it, else switch to it.

#+BEGIN_SRC emacs-lisp
  (defun my/other-window-or-split ()
    "Switch to other window or split it."
    (interactive)
    (when (one-window-p)
      (split-window-horizontally))
    (other-window 1))
#+END_SRC
